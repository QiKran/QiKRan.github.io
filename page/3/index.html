<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Kran</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Kran">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Kran">
<meta property="og:description" content="blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="QiKran">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Kran" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Kran</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-xml知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/xml%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2020-07-14T08:16:02.660Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/xml%E7%9F%A5%E8%AF%86%E7%82%B9/">xml知识点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="XML-知识"><a href="#XML-知识" class="headerlink" title="XML 知识"></a>XML 知识</h1><blockquote>
<p>eXtensible Markup Language, 可扩展的标记语言， 它是一种数据的载体，用来描述数据的以及数据的结构。</p>
<p>它是一种纯文本的数据格式。所以，XML数据是可以跨语言平台的。【与编程语言无关】</p>
<p>只不过JAVA语言提供了一套API，用来解析和生成XML文档。</p>
</blockquote>
<h2 id="XML的语法"><a href="#XML的语法" class="headerlink" title="XML的语法"></a>XML的语法</h2><ol>
<li><p>它的所有标记都是以 <strong>&lt;&gt;</strong> 括起来。</p>
</li>
<li><p>标记必需成对出现，以<strong>&lt;&gt; &lt;/&gt;</strong> 括起来。</p>
</li>
<li><p>标记中可以添加属性或者子标记，属性的语法是 <code>属性名=值</code>，多个属性之间使用空格隔开。在同一个标记中，不能存在相同的属性名。</p>
</li>
<li><p>文档中第一条都是：<?xml version="" encoding="" ?>  处理指令。</p>
</li>
</ol>
<blockquote>
<p>所以，只要是满足xml语法规范的文档，就叫xml 文档</p>
</blockquote>
<h2 id="XML的作用"><a href="#XML的作用" class="headerlink" title="XML的作用"></a>XML的作用</h2><ol>
<li>数据交换【跨语言平台的】</li>
<li>配置文件</li>
</ol>
<h2 id="如何编写一个xml文档？"><a href="#如何编写一个xml文档？" class="headerlink" title="如何编写一个xml文档？"></a>如何编写一个xml文档？</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>jack<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>19<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hobby</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>编程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>jack<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>19<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hobby</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>编程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">age</span>=<span class="string">"19"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>jack<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">hobby</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>编程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有关属性和标记的区别</p>
<ol>
<li>属性简单，标记复杂</li>
<li>属性没有扩展性，标记有很好的扩展性。</li>
</ol>
<p>不管是属性，还是标记，其目的都是用来描述<strong>数据</strong></p>
<h2 id="请自行定义一个xml文档，用来描述所你玩的游戏，标记名自定。"><a href="#请自行定义一个xml文档，用来描述所你玩的游戏，标记名自定。" class="headerlink" title="请自行定义一个xml文档，用来描述所你玩的游戏，标记名自定。"></a>请自行定义一个xml文档，用来描述所你玩的游戏，标记名自定。</h2><h2 id="格式良好的xml"><a href="#格式良好的xml" class="headerlink" title="格式良好的xml"></a>格式良好的xml</h2><blockquote>
<p>只要满足XML的语法规则即可。</p>
</blockquote>
<p>在实际的应用系统中，光格式良好的XML还是不够的，因为它们没有统一的规则，比如：根标记的名字，属性的定义，出现的次数，以及类型等等。</p>
<h2 id="如何定义一个合法的XML文档？"><a href="#如何定义一个合法的XML文档？" class="headerlink" title="如何定义一个合法的XML文档？"></a>如何定义一个合法的XML文档？</h2><blockquote>
<p>合法的XML是指，XML文档在满足格式良好的基础上，还要进一步去满足业务系统中定义的规则，这个规则一般是要重新定义的，采用 DTD 或 Schema 来定义这个规则。【DTD 现在使用不多，我们只讲schema】</p>
</blockquote>
<h3 id="何为schema"><a href="#何为schema" class="headerlink" title="何为schema?"></a>何为schema?</h3><blockquote>
<p>一套用来规定xml文档约束的规范，它本身就是xml，所不同的是，它的标记是由W3C官方定义好的，不是随便写的。</p>
<p>它的语法：</p>
<p>完全满足XML语法</p>
</blockquote>
<h3 id="schema常用的标记有："><a href="#schema常用的标记有：" class="headerlink" title="schema常用的标记有："></a>schema常用的标记有：</h3><ol>
<li><element></li>
<li><attribute></li>
<li><complexType></li>
<li><restriction></li>
<li><enumeration></li>
<li><simpleType></li>
<li><schema></li>
<li>….</li>
</ol>
<p>比如： 我们规定用来描述学员的xml文档有如下规则：</p>
<ol>
<li>根标记必需叫 <students></li>
<li>它的一级子标记必需叫 <student>，而且这个标记有仅只有1个属性，叫 id</li>
<li>student的子标记包含：<ol>
<li><name></li>
<li><age></li>
<li><gender></li>
</ol>
</li>
<li>要求，name,age, gender的顺序是固定的，而且它们都至多只能出现1次，gender可有可无</li>
</ol>
<p>按照如上的规则，则我们写出来的xml只能是如下结构：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;students&gt;</span><br><span class="line">	&lt;student id=<span class="string">"1"</span>&gt;</span><br><span class="line">		&lt;name&gt;&lt;/name&gt;</span><br><span class="line">		&lt;age&gt;&lt;/age&gt;</span><br><span class="line">		&lt;gender&gt;&lt;/gender&gt;</span><br><span class="line">    &lt;/student&gt;</span><br><span class="line">    &lt;student id=<span class="string">"1"</span>&gt;</span><br><span class="line">		&lt;name&gt;&lt;/name&gt;</span><br><span class="line">		&lt;age&gt;&lt;/age&gt;</span><br><span class="line">		&lt;gender&gt;&lt;/gender&gt;</span><br><span class="line">    &lt;/student&gt;</span><br><span class="line">    &lt;student id=<span class="string">"1"</span>&gt;</span><br><span class="line">		&lt;name&gt;&lt;/name&gt;</span><br><span class="line">		&lt;age&gt;&lt;/age&gt;</span><br><span class="line">    &lt;/student&gt;</span><br><span class="line">&lt;/students&gt;</span><br></pre></td></tr></table></figure>

<p>相对应的schema，应该是这样定义的：</p>
<p><strong>students.xsd</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"students"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"student"</span> <span class="attr">type</span>=<span class="string">"stuType"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:complexType</span> <span class="attr">name</span>=<span class="string">"stuType"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"xs:int"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="XML的命名空间-namespace"><a href="#XML的命名空间-namespace" class="headerlink" title="XML的命名空间[namespace]"></a>XML的命名空间[namespace]</h3><blockquote>
<p>用来扩展标记的命名。</p>
<p>语法：</p>
<elementName xmlns:alias="URL">

<p>表示以 alias 来代表后面的URL， 使用这个命名空间的标记或属性，都表示以alias所代表的URL打头。</p>
</blockquote>
<p>如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"students"</span>&gt;</span></span><br><span class="line">    	...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或：默认命名空间</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">"students"</span>&gt;</span></span><br><span class="line">    	...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="JAVA处理XML文档的API"><a href="#JAVA处理XML文档的API" class="headerlink" title="JAVA处理XML文档的API"></a>JAVA处理XML文档的API</h2><ol>
<li>JAXP， Java API for XML Parser/Processing,  JAVA XML解析/处理API， 它包含如下两种实现方式<ol>
<li>SAX, Simple API for XML, 是一种基于事件驱动的解析方式。特点是高效、快速，适合做超大型XML文档解析。主要的代码入口：<strong>javax.xml.parsers.SAXParserFacotry和 SAXParser</strong></li>
<li>DOM, Document Object Model, 文档对像模型，是基于内存中构建一整套的对象模型来解析的。特点是：可以修改，可以生成文档，缺点是：内存消耗较大。现代浏览器解析网页文件都是采用DOM模型。</li>
</ol>
</li>
<li>JAXB， Java Architecture for XML Binding,  XML绑定的JAVA架构，它是基于注解来在XML文档和JAVA实体对象之间进行映射的一种技术，它也叫 OXM【Object Xml Mapping】。 所在包：<strong>javax.xml.bind</strong> </li>
</ol>
<h3 id="JAXB-的使用"><a href="#JAXB-的使用" class="headerlink" title="JAXB 的使用"></a>JAXB 的使用</h3><p><strong>注解：</strong></p>
<ol>
<li>XmlRootElement     标注根节点</li>
<li>XmlElement   标注元素</li>
<li>XmlAttribute  标注属性</li>
<li>XmlType   标注子元素的顺序[xs:sequence]</li>
<li>XmlAccessorType 标注OXM生成时的策略，它的参数是 <strong>XmlAccessType</strong> 枚举类型</li>
<li>XmlAccessOrder  标注OXM生成时，是否按属性或getter/setter方法的字母顺序排列 [xs:sequence]</li>
<li>XmlTransient  标注某个属性或getter/setter方法对，不生成对应的XML元素</li>
<li>XmlElementWrapper 用来包装子元素的标注。一般用在集合属性或数组属性上面。</li>
<li>XmlJavaTypeAdapter  用来指定我们自定义的类型适配器的，当然，类型适配器需要我们自已开发。它需要继承 <strong>XmlAdapter</strong> 类</li>
<li>…</li>
</ol>
<p><strong>相关的处理类:</strong></p>
<ol>
<li>JAXBContext  JAXB处理上下文类，是一个核心类</li>
<li>Marshaller XML编组类，把JAVA对象编组成XML文档的类型 </li>
<li>UnMarshaller XML解组类，把 xml文档解组为java对象</li>
</ol>
<p>JDK7之后，引入了 <strong>JAXB 类</strong>, 这是一个工具类，可以直接编组和解组，无需通过 Marshaller和UnMarshaller </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/xml%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="ckcmpx87l001mcghcd3q692vr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Servlet" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/Servlet/" class="article-date">
  <time datetime="2020-07-14T08:16:02.657Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/Servlet/">Servlet</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Servlet</p>
<p>第一次请求servlet时  会初始化servlet对象  然后调用init方法 该过程需要花费时间，且只花在第一次调用servlet的用户上，后面则不需要，每次只需访问service方法。</p>
<p>如若在web.xml中 配置了<load-on-startup>1</load-on-startup> 则会在容器创建 而不是在第一次请求servlet时创建了 1代表优先级</p>
<p>ServletContext：应用</p>
<p>ServletConfig：配置</p>
<p>Servlet</p>
<p>应用对应多个Servlet</p>
<p>一个Servlet对应一个配置</p>
<p>一个容器只有一个ServletContext</p>
<p>重定向会改变地址栏的地址（模拟新的请求）</p>
<p>Session 一种基于cookie  另一种基于 url重写</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/Servlet/" data-id="ckcmpx861000kcghcg3pk0zoe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LocalDateTimes时间格式化解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/LocalDateTimes%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2020-07-14T08:16:02.655Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/LocalDateTimes%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%A7%A3%E6%9E%90/">LocalDateTimes时间格式化解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>LocalDateTimes时间格式化解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt=LocalDateTime.now();</span><br><span class="line">       DateTimeFormatter dateTimeFormatter = 					DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">       String text = dateTimeFormatter.format(ldt);</span><br><span class="line">       System.out.println(text);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/LocalDateTimes%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%A7%A3%E6%9E%90/" data-id="ckcmpx85k0004cghc5w4odryp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-IO底层交互相关杂记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/IO%E5%BA%95%E5%B1%82%E4%BA%A4%E4%BA%92%E7%9B%B8%E5%85%B3%E6%9D%82%E8%AE%B0/" class="article-date">
  <time datetime="2020-07-14T08:16:02.653Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/IO%E5%BA%95%E5%B1%82%E4%BA%A4%E4%BA%92%E7%9B%B8%E5%85%B3%E6%9D%82%E8%AE%B0/">IO底层交互相关杂记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="IO底层交互"><a href="#IO底层交互" class="headerlink" title="IO底层交互"></a>IO底层交互</h2><p>IO 是通过  操作系统对 IO硬件设备进行交互<br>如果未用  Buffer   那么 每次用IO流  进行交互<br>那么每次 读取 都会对IO硬件设备  进行一次交互<br>这样  大大降低了性能<br>那么如果用了 Buffer  则会把读取到的数据暂存到BUFFer中<br>  然后再判断 是否还要进行读取 最后对IO设备进行交互</p>
<p>（内存&lt;–&gt;IO设备）</p>
<p>fill（）一定会对IO设备进行交互<br>但 read不一定</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/IO%E5%BA%95%E5%B1%82%E4%BA%A4%E4%BA%92%E7%9B%B8%E5%85%B3%E6%9D%82%E8%AE%B0/" data-id="ckcmpx85h0002cghce6rl28ab" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTML杂记 Emmet语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/HTML%E6%9D%82%E8%AE%B0%20Emmet%E8%AF%AD%E6%B3%95/" class="article-date">
  <time datetime="2020-07-14T08:16:02.650Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/HTML%E6%9D%82%E8%AE%B0%20Emmet%E8%AF%AD%E6%B3%95/">HTML杂记 Emmet语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>tr<em>3&gt;td{$}</em>4  快速生成  三行 每行4列。<br>p*5&gt;spanP{标签名:}+input  每行用P其中包含span元素 span里包含input</p>
<p>formaction 可对一个表单再添加一个  提交按钮 可以是图片按钮</p>
<p>display    inline-block;  内联 块级元素。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/HTML%E6%9D%82%E8%AE%B0%20Emmet%E8%AF%AD%E6%B3%95/" data-id="ckcmpx85g0001cghceyshe0n6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-execution( transfer(..))java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/execution(%20transfer(..))java/" class="article-date">
  <time datetime="2020-07-14T08:16:02.633Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/execution(%20transfer(..))java/">execution( transfer(..))java</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* transfer(..))</span><br></pre></td></tr></table></figure>

<p>第一个*处的位置标识的返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)</span><br><span class="line">            <span class="keyword">throws</span>-pattern?)</span><br></pre></td></tr></table></figure>

<p>除返回类型 pattern(前面的代码片段中的<code>ret-type-pattern</code>)， name pattern 和参数 pattern 之外的所有部分都是可选的。返回类型 pattern 确定方法的 return 类型必须在 order 中才能匹配连接点。 <code>*</code>最常用作返回类型 pattern。它匹配任何 return 类型。仅当方法返回给定类型时，fully-qualified 类型 name 才匹配。 name pattern 与方法 name 匹配。您可以使用<code>*</code>通配符作为 name pattern 的全部或部分。如果指定声明类型 pattern，请包含尾随<code>.</code>以将其连接到 name pattern component。参数 pattern 稍微复杂一些：<code>()</code>匹配不带参数的方法，而<code>(..)</code>匹配任何数量(零个或多个)参数。 <code>(*)</code> pattern 匹配一个接受任何类型的一个参数的方法。 <code>(*,String)</code>匹配一个带两个参数的方法。第一个可以是任何类型，而第二个必须是<code>String</code>。有关更多信息，请参阅 AspectJ 编程指南的<a href="https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html" target="_blank" rel="noopener">语言语义学</a>部分。</p>
<ul>
<li>执行任何公共方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> * *(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 name 以<code>set</code>开头的任何方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* set*(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>执行<code>AccountService</code>接口定义的任何方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.xyz.service.AccountService.*(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>执行<code>service</code>包中定义的任何方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.xyz.service.*.*(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>执行服务包中定义的任何方法或其中一个 sub-packages：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.xyz.service..*.*(..))</span><br></pre></td></tr></table></figure>

<ul>
<li>服务包中的任何连接点(仅在 Spring AOP 中执行方法)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">within(com.xyz.service.*)</span><br></pre></td></tr></table></figure>

<ul>
<li>服务包中的任何连接点(仅在 Spring AOP 中执行方法)或其中一个 sub-packages：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">within(com.xyz.service..*)</span><br></pre></td></tr></table></figure>

<ul>
<li>代理实现<code>AccountService</code>接口的任何连接点(仅在 Spring AOP 中执行方法)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>(com.xyz.service.AccountService)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/execution(%20transfer(..))java/" data-id="ckcmpx87f001ecghchdvhh9zk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day20-多线程、网络编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/day20-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2020-07-14T08:16:02.618Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/day20-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">day20-多线程、网络编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><blockquote>
<p>正在运行的程序，现代的操作系统都是多任务【多进程】、多用户的</p>
<p>JVM就 是一个进程【process】， 当我们启动JVM时，就是启动了一个进程</p>
</blockquote>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><blockquote>
<p>运行在进程内部的一种资源，同样也是由OS负责调度， 一个进程中的所有线程都会共享此进程的资源，也有线程所独享的资源。</p>
<p>理论上来说，进程中可以启动很多个线程。</p>
<p>可以这么说，现代的软件都是基于线程的。</p>
</blockquote>
<p><strong>一个软件程序可以有多个进程，每一个进程又可以包含多个线程</strong></p>
<p>注：不管是进程，还是线程，都是操作系统级别的资源。</p>
<p>所以，线程和进程执行时，都需要OS的调度，所谓调度，就是给进程或线程所要执行的环境，这个环境就包含两个东西：</p>
<ol>
<li>CPU时间片， 把CPU的执行时间拆分成一个一个的小时间段。</li>
<li>内存，因为硬盘的运行整度跟不上CPU，而CPU的存储空间又不可能做到很大。</li>
</ol>
<h2 id="在JAVA中，如何去开发一个线程类"><a href="#在JAVA中，如何去开发一个线程类" class="headerlink" title="在JAVA中，如何去开发一个线程类"></a>在JAVA中，如何去开发一个线程类</h2><h3 id="方式一，直接继承-java-lang-Thread-类"><a href="#方式一，直接继承-java-lang-Thread-类" class="headerlink" title="方式一，直接继承 java.lang.Thread 类"></a>方式一，直接继承 java.lang.Thread 类</h3><ol>
<li>public Thread()    </li>
<li>public Thread(Runnable r)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        <span class="comment">//就是此线程被OS调度后要执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程对象，启动线程</span></span><br><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.start(); <span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure>



<p>注： 当我们启动线程时，不是调用run方法，而是调用 start 方法。</p>
<p>start() 表示，JVM告诉OS, 我这里有一个线程对象，需要你的调度。</p>
<p>一个线程一旦调用了start方法，表示进入了 “可运行态”，只有当OS分配了CPU时间片后，才会真正执行，也就是进入了“运行态”。</p>
<h3 id="方式二，实现-java-lang-Runnable-接口，并以这个接口的实例做为参数来构造-Thread对象"><a href="#方式二，实现-java-lang-Runnable-接口，并以这个接口的实例做为参数来构造-Thread对象" class="headerlink" title="方式二，实现 java.lang.Runnable 接口，并以这个接口的实例做为参数来构造 Thread对象"></a>方式二，实现 java.lang.Runnable 接口，并以这个接口的实例做为参数来构造 Thread对象</h3><ol>
<li>首先，开发一个类来实现 Runnable 接口，如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>其次，创建一个Thread对象，并以 MyRun的对象做为参数，如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRun());</span><br><span class="line">t.start(); <span class="comment">//启动线程， 不是调用 run 方法</span></span><br></pre></td></tr></table></figure>



<h3 id="Thread中的常用方法"><a href="#Thread中的常用方法" class="headerlink" title="Thread中的常用方法"></a>Thread中的常用方法</h3><ol>
<li>join() 方法，当前线程如果调用另一个线程的join方法，表示当前线程进入阻塞，直到被调用了join方法的线程运行结束。</li>
<li>yield() 方法，当前线程调用了yield方法后，表示当前线程立即从运行态回到可运行态，再次等待CPU的调度。</li>
<li>sleep() 方法，当前线程调用了此方法，则当前线程进入阻塞。</li>
<li>interrupt() 方法，中断方法，也就给目标线程发送<strong>中断</strong>信号.  目标线程即使处在阻塞状态，也能接收中断信号，一旦接收到中断信息，立刻打破阻塞。</li>
</ol>
<h3 id="JVM进程中的线程"><a href="#JVM进程中的线程" class="headerlink" title="JVM进程中的线程"></a>JVM进程中的线程</h3><ol>
<li>当JVM进程启动后，就会启动2个线程，其中</li>
</ol>
<ul>
<li>主线程，也叫main线程，它负责调用你的程序中的main方法</li>
<li>垃圾回收线程，也叫GC线程，它是一个后台守护线程，也叫Daemon线程。</li>
</ul>
<p>当JVM进程中，所有的非守护线程都结束后，JVM进程就结束。</p>
<p>所以，在我们之前所开发的所有案例中，当main方法执行结束，JVM进程就结束了。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ol>
<li>初始态, 创建了一个线程对象，没有调用start之前的状态</li>
<li>可运行态【Runnable】，调用了start()方法之后</li>
<li>运行态【Running】, 正在执行中的线程</li>
<li>终止态【Terminate】, 线程执行结束</li>
<li>阻塞态【Blocking】,  又分成如下3种情况<ol>
<li>普通阻塞，比如：调用了 sleep()方法，join()方法， 等待用户的输入。</li>
<li>锁池阻塞，当一个线程拿不到目标资源的互斥锁时，就会进入到目标资源[对象]的锁池中阻塞</li>
<li>等待队列，当多个线程进行通信息，当前线程调用了目标资源[对象]wait()方法，则当前线程进入等待队列阻塞，直到其它线程调用了目标资源的notify或 notifyAll方法。</li>
</ol>
</li>
</ol>
<h3 id="锁资源"><a href="#锁资源" class="headerlink" title="锁资源"></a>锁资源</h3><blockquote>
<p>如果我们的代码使用了同步关键字[synchronized], 则就需要使用临界资源对象来达到互斥的目的，如果每线程都拥有各自的一份临界资源，则这个临界资对象就不能在线程间才互斥。</p>
<p><strong>锁 同一种互斥资源，它是对象所拥有的</strong></p>
</blockquote>
<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><blockquote>
<p>用来做代码的同步的，有两种语法：</p>
<ol>
<li>直接加在方法的修饰符位置。这表示采用<strong>当前对象</strong>做为临界资源对象。</li>
<li>使用 <strong>synchronized(对象)</strong> 方式，这种方式可以自己指定临界资源对象。 【*****】</li>
</ol>
</blockquote>
<h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><p>前提：</p>
<ol>
<li>一要要有同步</li>
<li>要有临界资源的抢占</li>
</ol>
<p>使用wait()和notify()或notifyAll() 来完成</p>
<h2 id="死锁-【deadLock】"><a href="#死锁-【deadLock】" class="headerlink" title="死锁 【deadLock】"></a>死锁 【deadLock】</h2><blockquote>
<p>多个线程之间互相申请对方的互斥锁资源时，就会产生死锁。</p>
<p>写多线程代码时，要尽可能地避免。</p>
<p>如果有多个临界资源时，每个线程在申请临界资源的锁时，尽量保持顺序一致。</p>
</blockquote>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><blockquote>
<p>java.net 包, 主要包含如下类型</p>
<ol>
<li>ServerSocket   开发基于TCP协议的服务端应用程序</li>
<li>Socket               开发基于TCP协议的客户端应用程序</li>
<li>DataGramSocket   开发基于UDP协议的应用程序</li>
</ol>
</blockquote>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><blockquote>
<p>是网络通信协议中的一种，处于TCP/IP网模型中的传输层。全称是：Transfer Controll Protocol, 传输控制协议， 它是一种面向连接的网络协议，是安全的。它的建立需要经过三次握手，以保证连接的可靠性。</p>
<p>对于JAVA的网络API而言，程序员是不需要理解底层的网络机制，JDK的API都帮我们封装好了。这个封装好的类型就是 <strong>Socket和ServerSocket</strong></p>
</blockquote>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><blockquote>
<p>也是网络通信协议的一种，而且也是处于TCP/IP网络模型中的传输层，与TCP是一样。所不同的是，UDP是非面向连接的，而且不保证数据传输的可靠性【有可能会丢包】，适合做 视频会议、网络课堂等 应用。</p>
</blockquote>
<h3 id="开发服务端"><a href="#开发服务端" class="headerlink" title="开发服务端"></a>开发服务端</h3><ol>
<li>创建ServerSocket对象</li>
<li>进行监听，等待客户端的连接，调用 accept(), 连接成功，就会返回 Socket</li>
<li>创建一个线程为客户端进行服务，并以 Socket  做为参数</li>
</ol>
<h3 id="开发客户端"><a href="#开发客户端" class="headerlink" title="开发客户端"></a>开发客户端</h3><ol>
<li>创建 Socket  对象， 要指定你要连接的服务端的IP地址和端口</li>
<li>通过Socket来获取输入/输出流或者 通道[Channel]</li>
<li>读、写 数据</li>
</ol>
<h3 id="端口是什么-？"><a href="#端口是什么-？" class="headerlink" title="端口是什么 ？"></a>端口是什么 ？</h3><blockquote>
<p>每个需要网络通信的进程都需要唯一的端口，系统会自动为这些进程分配端口，最多可以分配出 65536个。</p>
<p>有些常用的网络协议，会固定占用一些端口，在OS中，1024以下的端口都是被系统预先征用的，我们的应用程序的端口最好超过这个大小。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/day20-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="ckcmpx877001bcghc4f235syt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day19-NIO、Lambda表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/day19-NIO%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time datetime="2020-07-14T08:16:02.608Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/day19-NIO%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">day19-NIO、Lambda表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="Channel-java-nio-channels"><a href="#Channel-java-nio-channels" class="headerlink" title="Channel [java.nio.channels]"></a>Channel [java.nio.channels]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Channel</span><br><span class="line">    \- ReadableByteChannel               可读的通道</span><br><span class="line">    		\- ScatteringByteChannel     把同一个通道中的字节读到多个字节缓存中，这个过程叫分散</span><br><span class="line">    \- WriteableByteChannel              可写的通道</span><br><span class="line">    		\- GatheringByteChannel      把多个缓存中的字节写入到同一个通道中，这个过程叫聚集</span><br><span class="line">    		\- ByteChannel</span><br><span class="line">    				\- SeekableByteChannel    可以保持并调节位置的通道</span><br><span class="line">    					\- FileChannel         针对文件的通道，不支持配置为非阻塞模式</span><br><span class="line">    </span><br><span class="line">    \- SelectableChannel                  可通过Selector复用的通道,提供了配置非阻塞的方法</span><br><span class="line">    		\- AbstractSelectableChannel</span><br><span class="line">                    \- DatagramChannel     针对网络的UDP协议,支持 非阻塞模式</span><br><span class="line">                    \- SocketChannel	   针对网络的TCP协议，这个类是做客户端，支持 非阻塞模式	</span><br><span class="line">                    \- ServerSocketChannel 针对网络的TCP协议，这个类是做服务端的，支持 非阻塞模式</span><br></pre></td></tr></table></figure>

<h3 id="Channel的核心方法"><a href="#Channel的核心方法" class="headerlink" title="Channel的核心方法"></a>Channel的核心方法</h3><ol>
<li><p><strong>从通道中读取数据到缓存中</strong></p>
<p>int read(ByteBuffer buffer)     把通道中的字节数据存储到缓冲中，并返回实际读到的字节数。</p>
<p>long read(ByteBuffer[] bufArr)   把通道中的字节数据分散读到多个缓冲中，并返回实际读到的字节数。</p>
<p>long position()                    获取通道中当前文件指定的位置</p>
<p>FileChannel position(long pos)   设置通道中文件指针的位置，这个值可以大于文件大小，但是，只是读的话，并不改变文件大小，如果 写入，则文件会生长，以适应新的大小。</p>
<p>long size()     返回此通道的大小，其实就是文件通道所指向的文件的大小。</p>
</li>
</ol>
<ol start="2">
<li><p><strong>把缓存中的数据写入到通道</strong></p>
<p>int write(ByteBuffer buffer);</p>
<p>long write(ByteBuffer[] bufArray);</p>
</li>
</ol>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><blockquote>
<p>一组固定大小的连续空间，用来存储从通道中读到的数据。</p>
<p>它的操作主要就是：</p>
<ol>
<li>缓存中数据的读写</li>
<li>缓存中各种标记位置的控制</li>
</ol>
</blockquote>
<p>类的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Buffer</span><br><span class="line">   \- ByteBuffer</span><br><span class="line">   		\- HeapByteBuffer      非直接缓存</span><br><span class="line">   		\- MappedByteBuffer</span><br><span class="line">   			\- DirectByteBuffer    直接缓存</span><br><span class="line">   \- CharBuffer</span><br><span class="line">   \- ShortBuffer</span><br><span class="line">   \- IntBuffer</span><br><span class="line">   \- LongBuffer</span><br><span class="line">   \- DoubleBuffer</span><br><span class="line">   \- FloatBuffer</span><br></pre></td></tr></table></figure>

<p>注：默认情况下，都会分配非直接缓存，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>); <span class="comment">//非直接缓存</span></span><br><span class="line"></span><br><span class="line">ByteBuffer buffer2 = ByteBuffer.allocateDirect(<span class="number">1024</span>); <span class="comment">//直接缓存</span></span><br></pre></td></tr></table></figure>

<p><strong>常用方法</strong></p>
<ul>
<li>int position()                 返回缓存中当前位置</li>
<li>int limit();                       返回缓存中限制的位置</li>
<li>int capacity();                返回缓存的容量</li>
<li>mark()                          在当前位置进行标记</li>
<li>flip()    反转，用来读写转换中。</li>
<li>clear()   清空缓存，并没有清空数据，只是重置了 mark, position, limit的值</li>
<li>compact()   是一个可选方法，压缩</li>
<li>wrap(byte[] buf)    以指定的字节数组来填充这个缓存，缓存的大小capacity就是 buf.length</li>
</ul>
<p>有关这4个属性，满足：</p>
<p><strong>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</strong></p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><blockquote>
<p>后面再讲</p>
</blockquote>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><blockquote>
<p>它本质是JDK提供给程序员在编写代码语法上的一种便捷方式，也叫语法糖。</p>
<p>JAVA的语法规范上，方法的参数是不能以代码块[函数] 进行传递的。不像 javascript, 那我们如何才能写出传 递代码块的方法呢？</p>
<p>JDK8中，引入了Lambda表达式以及函数式接口，就是为解决这个问题而存在的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ma</span><span class="params">(只有<span class="number">1</span>个方法的接口 identifier)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    System.out.println(<span class="string">"ma的功能操作...."</span>);</span><br><span class="line">    <span class="comment">//中间这此代码，此时，做为ma方法编写者，我不知道这个地方要写什么，将来谁调用这个方法，谁知道，那就要求，调用者要把这个代块给 传进来给我。</span></span><br><span class="line">    identifier.xxx(); <span class="comment">//相当于完成了 代码块 的传递</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"ma的功能操作.... "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>上面的方法中的参数 “只有1个方法的接口” 是JVM为了达到代码传递的目的，而准备的一个特殊的接口，这个接口在JDK8中，叫函数式接口，使用一个注解来标注 <code>@FunctionalInterface</code></p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><blockquote>
<p>在JDK8中规定，某个接口上面打上了 <code>@FunctionalInterface</code>，就表示这个接口就是函数式接口，通过它就可以来接收代码块的传递，而且为了语法的方便性，才推出了 Lambda 表达式。</p>
<p>另外，由于在JDK中，有很多接口都是单一方法的，所以，JVM还规定，只有接口中只有唯一的抽象方法时【除继承于Object中的方法外】，即使你没有显示地使用 <code>@FunctionalInterface</code> 注解，JVM也认为它就是 函数式接口。</p>
</blockquote>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ia</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ma</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIa</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mb</span><span class="params">(Ia identifer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before invoke ia ... "</span>);</span><br><span class="line">        <span class="comment">//回调 Ia 接口的方法</span></span><br><span class="line">        identifer.ma();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"after invoke ia ..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        TestIa ti = <span class="keyword">new</span> TestIa();</span><br><span class="line">        ti.mb(() -&gt; &#123;System.out.println(<span class="string">"in method ma()...."</span>);&#125; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Lambda-的语法规范"><a href="#Lambda-的语法规范" class="headerlink" title="Lambda 的语法规范"></a>Lambda 的语法规范</h3><blockquote>
<p>(Type param1, Type param2, …., Type paramN) -&gt; {</p>
<p>​               //代码块</p>
<p>}</p>
</blockquote>
<p>这个语法可以简化如下：</p>
<ol>
<li>参数的类型可以省略，就变成了</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(param1,param2,...,paramN) -&gt; &#123;   &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果参数的个数只有1个时，小括号也可以省略</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param -&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果代码块中只有1条语句，大括号也可以省略</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param -&gt; one_statement;</span><br></pre></td></tr></table></figure>



<p>注：所有使用匿名内部类的地方，都可以使用<strong>Lambda表达式</strong>来改写</p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><blockquote>
<p>它是Lambda表达式的另一种特殊写法，本质上还是 Lambda表达式， 改写条件</p>
<ol>
<li>Lambda表达式当中只有单一一条语句</li>
<li>这条语句是调用已有的方法</li>
</ol>
</blockquote>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;jack&quot;,&quot;ann&quot;,&quot;solo&quot;);</span><br><span class="line">&#x2F;&#x2F; Lambda表达式</span><br><span class="line">list.forEach((element) -&gt; System.out.println(element));</span><br><span class="line">&#x2F;&#x2F;方法引用</span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>



<h3 id="在Lambda表达式中访问局部变量的限制"><a href="#在Lambda表达式中访问局部变量的限制" class="headerlink" title="在Lambda表达式中访问局部变量的限制"></a>在Lambda表达式中访问局部变量的限制</h3><blockquote>
<p>在JDK7之前，匿名内部类中可以访问它所在方法的局部变量，但是，要求这个局部变量要使用 final 修饰，在JDK7之后，这个final可以不写，但是，在匿名内部类当中，不能去修改这个局部变量。</p>
<p>同理，LAMBDA表达式本身就是 匿名内部类的语法优化，所以，在Lambda表达式内部，同样不能修饰所在方法的局部变量。</p>
</blockquote>
<p>Lambda表达式的操作包</p>
<p>java.util.function</p>
<p>java.util.stream</p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>复习Lambda知识点</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/day19-NIO%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="ckcmpx876001acghc1avo007o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day18-注解解析、代理、NIO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/day18-%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E3%80%81%E4%BB%A3%E7%90%86%E3%80%81NIO/" class="article-date">
  <time datetime="2020-07-14T08:16:02.592Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/day18-%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E3%80%81%E4%BB%A3%E7%90%86%E3%80%81NIO/">day18-注解解析、代理、NIO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="注解解析程序"><a href="#注解解析程序" class="headerlink" title="注解解析程序"></a>注解解析程序</h1><blockquote>
<p>Annotation Process/Parse Tool, APT, 它是我们利用反射API进行注解处理的一种程序。</p>
<p>注解是通过代码的方式进行程序辅助的，JDK中提供了一些注解，包含元注解</p>
<ul>
<li>@Override</li>
<li>@SuppressWarnings</li>
<li>@Deprecated</li>
<li>@SafeVarargs    JDK7加入</li>
<li>@FunctionalInterface  JDK8加入</li>
<li>@Documented</li>
<li>@Inherited</li>
<li>@Retention(value=RetentionPolicy.XXX)<ul>
<li>Retention.SOURCE</li>
<li>Retention.CLASS</li>
<li>Retention.RUNTIME</li>
</ul>
</li>
<li>@Target(value={ElelmentType.XXX, XXXX,XXXX})<ul>
<li>ElementType.METHOD</li>
<li>ElementType.TYPE</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>注：元注解是用来修饰其它注解的注解</strong></p>
</blockquote>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用元注解修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    <span class="comment">//参数的定义</span></span><br><span class="line">    类型 参数名() [<span class="keyword">default</span> 默认值]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解中参数的类型有以下几种：</p>
<ul>
<li><p>基本类型</p>
</li>
<li><p>String</p>
</li>
<li><p>枚举</p>
</li>
<li><p>Class</p>
</li>
<li><p>注解</p>
</li>
<li><p>以上类型的数组</p>
</li>
</ul>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><blockquote>
<p>可以在不改变原有对象源代码的基础上，添加新的功能。</p>
<p>它的机制：</p>
<ul>
<li>代理对象与被代理对象会实现同一个接口</li>
<li>利用JDK中提供的 Proxy和InvocationHandler 接口来实现。</li>
</ul>
</blockquote>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote>
<p>使用组合模式来实现</p>
</blockquote>
<p>案例：</p>
<p>//先定义一个接口 <strong>Movable</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//创建一个实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"汽车在移动...."</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//调用者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseMove</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Movable m = <span class="keyword">new</span> Car();</span><br><span class="line">        m.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//要求：在不改变 Car类的实现方法move()的情况下, 如何给这个car的move()添加新的操作?</p>
<h3 id="解决思路1，采用静态代理来做"><a href="#解决思路1，采用静态代理来做" class="headerlink" title="解决思路1，采用静态代理来做"></a>解决思路1，采用静态代理来做</h3><ol>
<li>开发一个<strong>代理类</strong>，这个代理类同样要实现 <strong>Movable</strong> 接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoveProxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Movable target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MoveProxy</span><span class="params">(Movable target)</span> </span>&#123; <span class="keyword">this</span>.target = target; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">"汽车在启动之前的检查操作"</span>);</span><br><span class="line">          </span><br><span class="line">       	<span class="comment">//调用被代理对象的真正业务</span></span><br><span class="line">        target.move();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//。。。</span></span><br><span class="line">        System.out.println(<span class="string">"汽车移动完成之后的操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//现在，调用者代码变成： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseMove</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Movable m = <span class="keyword">new</span> MoveProxy(<span class="keyword">new</span> Car());</span><br><span class="line">        m.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：在调用者这端，拿到的是 Car的代理对象</p>
<blockquote>
<p>注：<strong>静态代理可以达到我们的目的，但是，它的通用性和扩展不够，当接口中多出1个方法或再多实现一个接口时，不光被代理对象要进行修改，我们的静态代理类也要修改</strong>。</p>
</blockquote>
<h3 id="解决思路2，采用动态代理"><a href="#解决思路2，采用动态代理" class="headerlink" title="解决思路2，采用动态代理"></a>解决思路2，采用动态代理</h3><blockquote>
<p>利用JDK中自带的 <code>Proxy</code>和<code>InvocationHandler</code> 两个类型来完成。</p>
<p>要求：</p>
<p><strong>目标对象一定要有实现的接口，没有实现接口的目标对象，JDK自带的Proxy，没有能力为它生成代理对象。</strong></p>
</blockquote>
<h4 id="java-lang-reflect-Proxy"><a href="#java-lang-reflect-Proxy" class="headerlink" title="java.lang.reflect.Proxy"></a>java.lang.reflect.Proxy</h4><p>常用方法</p>
<ul>
<li><p>Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler);</p>
<p>其中</p>
<ul>
<li>ClassLoader 表示目标对象的类加载器</li>
<li>Class&lt;?&gt;[]  表示目标对象所实现的接口类型，可以有多个，所以才是数组</li>
<li>InvocationHandler  表示创建出来的代理对象要执行的代码，由程序员填入。</li>
</ul>
</li>
</ul>
<h4 id="java-lang-reflect-InvocationHandler"><a href="#java-lang-reflect-InvocationHandler" class="headerlink" title="java.lang.reflect.InvocationHandler"></a>java.lang.reflect.InvocationHandler</h4><p>常用方法</p>
<ul>
<li><p>Object invoke(Object proxy, Method m, Object[] args);</p>
<p>其中</p>
<ul>
<li>proxy  代理对象</li>
<li>Method  就是目标方法</li>
<li>args  就是目标方法的参数</li>
</ul>
</li>
</ul>
<h2 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h2><blockquote>
<p>JDK1.4推出的，提供一套全新的IO操作API，并没有完全否定老的API，因为在老的API中，提供了可以转换为NIO的操作。</p>
<p>NIO相比老的IO，可以从两个方面去理解它</p>
<ul>
<li>New IO</li>
<li>Non Blocking IO, 非阻塞的IO</li>
</ul>
</blockquote>
<p>在NIO中，主要有三个类型</p>
<ol>
<li><p><strong>Channel</strong></p>
<p>​    \- FileChannel            文件通道</p>
<p>​     \- DatagramChannel </p>
<p>​      \-  SocketChannel</p>
<p>​      \- ServerSocketChannel</p>
<p>注：它与IO中的Stream [流 ]是同一级别的。不同点在于 Channel是双向的【即可以读，也可以写】，它本身并不缓存数据，必需通过 Buffer, 也就是 Channel和Channel之间都是通过 Buffer 来交换数据的。</p>
</li>
</ol>
<ol start="2">
<li><p><strong>Buffer</strong></p>
<p>​     \- ByteBuffer</p>
<p>​     \- IntBuffer</p>
<p>​      \- …</p>
<blockquote>
<p>Buffer一旦创建，它的长度是固定的，利用 allocate(int capacity)  方法来分配，这个 capacity一旦确定，不可改变。</p>
</blockquote>
</li>
<li><p><strong>Selector</strong></p>
</li>
</ol>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ol>
<li><p>开发一个版权申明的注解@Copyright, 添加如下参数 </p>
<ul>
<li>公司名  字符串类型</li>
<li>开始年份 整型</li>
<li>结束年份 整型</li>
<li>描述  字符串</li>
</ul>
<p>要求：此注解可以添加类上面和方法上面</p>
</li>
<li><p>开发一个类，来解析添加了这个注解的类型，并把注解中的信息读取出来，打印出来即可</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/day18-%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E3%80%81%E4%BB%A3%E7%90%86%E3%80%81NIO/" data-id="ckcmpx87a001ccghc93sgfsgv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day17-反射、注解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/day17-%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time datetime="2020-07-14T08:16:02.575Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/day17-%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3/">day17-反射、注解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java反射和注解"><a href="#Java反射和注解" class="headerlink" title="Java反射和注解"></a>Java反射和注解</h1><h2 id="反射-Reflection"><a href="#反射-Reflection" class="headerlink" title="反射 Reflection"></a>反射 Reflection</h2><blockquote>
<p>提供了一套给程序员用来窥探字节码内部结构的机制。在JDK5开始引入的。</p>
<p>通过反射，我们可以把字节码反编译成源文件。</p>
</blockquote>
<p>所以，反射的程序都是从 字节码开始的。</p>
<h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><blockquote>
<p>就 是由  javac 编译 .java源文件后形成的文件， 以 .class 为扩展名。</p>
<p>那么 JVM 是如何去管理这个 字节码文件的。</p>
</blockquote>
<p>当.class文件被JVM加载进入内存后，这个字节码就会由JVM进行管理，而JVM中，需要一个类型来表达字节码，这个类型就是 <code>java.lang.Class</code></p>
<h3 id="java-lang-Class"><a href="#java-lang-Class" class="headerlink" title="java.lang.Class"></a>java.lang.Class</h3><blockquote>
<p>它就是一种JAVA数据类型，同 Scanner, LocalDate 等一样。</p>
<p>它的实例是用来表达字节码本身的一种对象。每个JAVA类型在被JVM加载进入内存后，JVM都会创建此类唯一的 Class实例。</p>
</blockquote>
<p>比如：JVM加载了Computer类进来，则JVM中就会创建一个 Computer的Class 实例。以此类推，加载了 LocalDate, Scanner, System, String等等，则在JVM就会对应创建 LocalDate的Class实例、Scanner的Class实例、System的Class实例、String的Class实例。</p>
<h3 id="如何获取-Class-实例？"><a href="#如何获取-Class-实例？" class="headerlink" title="如何获取 Class 实例？"></a>如何获取 Class 实例？</h3><p><strong>有三种方式可以获取</strong>:</p>
<ol>
<li>通过 <strong>Class.forName(String qualifiedName)</strong> 来获取， 程序员需要指定目标类型的全限定名【包名. 类名】</li>
<li>通过 <strong>类名.class</strong>  来获取</li>
<li>通过 <strong>对象.getClass()</strong> 来获取</li>
</ol>
<p>以上三种方式，对于同一个类型来说，得到的结果是一样的【JVM中，同一个类的Class实例是唯一的】</p>
<h3 id="通过类的Class实例，我们可以获取什么？"><a href="#通过类的Class实例，我们可以获取什么？" class="headerlink" title="通过类的Class实例，我们可以获取什么？"></a>通过类的Class实例，我们可以获取什么？</h3><ul>
<li>获取此类的包结构      —&gt;   getPackage  =&gt;  java.lang.Package </li>
<li>获取此类导入的类型     –&gt;  </li>
<li>类的修饰符                   –&gt;  getModifiers()   =&gt;  int</li>
<li>实现了哪些接口           –&gt;   getInterfaces()   =&gt;   Class&lt;?&gt;[]<ul>
<li>本身又是 Class 实例</li>
</ul>
</li>
<li>继承的父类                   –&gt;   getSuperclass()    =&gt;  Class&lt;? super T&gt;<ul>
<li>本身又是 Class 实例</li>
</ul>
</li>
<li>泛型信息                        –&gt;   getTypeParameters()    =&gt;  TypeVariable[]<ul>
<li>。。。</li>
</ul>
</li>
<li>属性信息                       –&gt;  getFields()   =&gt;   Field[]<ul>
<li>属性修饰符            –&gt;  getDeclaredFields()   =&gt; Field[]</li>
<li>属性类型               –&gt;  getField(String fieldName)    =&gt;  Field</li>
<li>属性名</li>
</ul>
</li>
<li>构造方法信息                 –&gt;  getConstructors()     =&gt;  Constructor[]<ul>
<li>修饰符                     –&gt;  getDeclaredConstructors()  =&gt; Constructor[]</li>
<li>参数列表                  </li>
</ul>
</li>
<li>方法信息                           –&gt;  getMethods()     =&gt;  Method[]<ul>
<li>方法修饰符                 –&gt;  getDeclaredMethods()   =&gt;  Method[]</li>
<li>方法的返回类型        –&gt;   getDeclaredMethod(String mName, Class… params)   =&gt; Method</li>
<li>方法名</li>
<li>方法的参数列表</li>
<li>方法申明抛出的异常列表</li>
</ul>
</li>
</ul>
<h3 id="反射API"><a href="#反射API" class="headerlink" title="反射API"></a>反射API</h3><blockquote>
<p>java.lang.reflect 包</p>
</blockquote>
<h3 id="为什么要用反射？"><a href="#为什么要用反射？" class="headerlink" title="为什么要用反射？"></a>为什么要用反射？</h3><blockquote>
<p>希望写出更通用的代码。</p>
<p>动态地给目标类添加新的功能，而不需要改变源码【代理 Proxy】</p>
</blockquote>
<h2 id="注解-Annotation-也叫标注"><a href="#注解-Annotation-也叫标注" class="headerlink" title="注解 Annotation [也叫标注]"></a>注解 Annotation [也叫标注]</h2><blockquote>
<p>用来提供代码的辅助信息，比如配置信息，以及一些需要编译器进行检查的信息</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="JDK内置的注解"><a href="#JDK内置的注解" class="headerlink" title="JDK内置的注解"></a>JDK内置的注解</h3><ul>
<li><p>在 java.lang中有3个</p>
<ul>
<li>@Override    用来告诉JVM的编译器去检查方法是否符合重写的规范</li>
<li>@Deprecated   用来告诉JVM的编译器，这个类或方法已经过时了</li>
<li>@SuppressWarnings  用来告诉JVM的编译器，对所指定的一些警告信息保持静默. 它包含：<ul>
<li>“serial”   针对实现了Serializable接口的类型，没有给出versionUID时的警告 保持静默</li>
<li>“unused”  针对定义了变量，但是这个变量从未使用过的警告保持静默</li>
<li>“unchecked” 针对一些未检查的警告保持静默</li>
<li>…</li>
<li>“all”   所有警告保持静默</li>
</ul>
</li>
</ul>
<p>JDK7和8中，又添加了2个</p>
<ul>
<li>@SafeVarargs</li>
<li>@FunctionalInterface  把某个接口标注为函数式接口。</li>
</ul>
</li>
<li><p>在java.lang.annotation中有4个, 这4个也叫 元注解[meta annotation, 就是用来标注其它注解的注解]</p>
<ul>
<li><p>@Documented     – 表示被此元注解修饰的注解可以进入到 javadoc的文档中</p>
</li>
<li><p>@Inherited    – 被此注解修饰过的注解使用类，如果这个类有子类的话，则子类将可以继承父类中的注解</p>
</li>
<li><p>@Retention    – 表示规定注解可以保留在什么层面上，有3个层面可以选择：</p>
<ul>
<li>SOURCE  – 表示注解只保留在编译期间，在字节码层面看不到这个注解。</li>
<li>CLASS  – 表示注解不止在编译期间，在字节码层面也存在，但是，JVM不能读取。</li>
<li>RUNTIME  – 表示注解不止在编译期间，在字节码层面也存在，而且JVM可以读取。</li>
</ul>
<p>注：如果我们开发注解，没有指定 @Retention 的话，则默认是 CLASS</p>
</li>
<li><p>@Target  – 表示注解可以修饰的类型是什么， 它同样有一个枚举来指定，包含如下值：</p>
<ul>
<li>TYPE</li>
<li>ANNOTATION_TYPE</li>
<li>METHOD</li>
<li>CONSTRUCTOR</li>
<li>FIELD</li>
<li>…</li>
</ul>
<p>注：如果我们开发注解，没有指定@Target的话，则默认是 所有地方都可以使有。</p>
<p><strong>一般来说，我们开发注解的话，最少应该要使用 @Retention 和  @Target</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="注解的特点"><a href="#注解的特点" class="headerlink" title="注解的特点"></a>注解的特点</h3><blockquote>
<p><strong>与枚举一样，它也是一种类型，而且所有的注解都会自动实现 java.lang.annotation.Annotation 接口</strong></p>
<p>所以，可以这么说，我们开发的每一个注解，都是 <strong>Annotation</strong> 接口的实现类。</p>
</blockquote>
<h3 id="Annotation-接口"><a href="#Annotation-接口" class="headerlink" title="Annotation 接口"></a>Annotation 接口</h3><blockquote>
<p>详见API</p>
</blockquote>
<h3 id="使用注解的语法"><a href="#使用注解的语法" class="headerlink" title="使用注解的语法"></a>使用注解的语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@注解名</span><br><span class="line">如果这个注解有参数的话，则给相应的参数</span><br><span class="line">@注解名(参数名=值,参数名=值)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//如：</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(value=&#123;<span class="string">"serial"</span>,<span class="string">"unused"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ma</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="注解有什么用？"><a href="#注解有什么用？" class="headerlink" title="注解有什么用？"></a>注解有什么用？</h3><ol>
<li>JDK自带的注解，JVM会对它进行解析，并给出相应的意义。</li>
<li>我们自已开发的注解，就需要程序员自己编写 解析代码，并指定相应的意义。</li>
</ol>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ol>
<li><p>设计一个产品类[Product]，包含如下属性：id, 产品名，产品分类，单价，上架时间 ，其中，产品分类是一个枚举。</p>
</li>
<li><p>设计 产品分类 枚举，包含如下常量： 家用电器，办公用品，运动户外，食品饮料，母婴玩具，服装鞋子</p>
</li>
<li><p>写一个程序，随机模拟1000个产品，利用List进行存储，然后写一个方法来完成如下任务</p>
<ol>
<li>统计出每种产品分类下的产品数量</li>
<li>按产品分类进归整，按价格高低列出每个产品分类下面的所有产品名称和单价。 大概的显示如下：</li>
</ol>
<p>家用电器分类</p>
<p>​    海尔冰箱          ￥10089.5</p>
<p>​    西门子洗衣机   ￥9988.5</p>
<p>​    。。。</p>
<p>运动户外分类</p>
<p>​    xxxx        $1145.5</p>
<p>​    …</p>
<p>….</p>
<p>​        …</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/day17-%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3/" data-id="ckcmpx8730019cghc4ir82mf9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/15/SpringMVC-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%B5%8B%E8%AF%95/">SpringMVC-控制器测试</a>
          </li>
        
          <li>
            <a href="/2020/07/15/Spring+mybatis%E6%95%B4%E5%90%88/">Spring+mybatis整合</a>
          </li>
        
          <li>
            <a href="/2020/07/15/Spring%20MVC-3/">Spring MVC-3</a>
          </li>
        
          <li>
            <a href="/2020/07/15/spring%20MVC-2/">spring MVC-2</a>
          </li>
        
          <li>
            <a href="/2020/07/15/Spring%20MVC-1/">Spring MVC-1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 QiKran<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>