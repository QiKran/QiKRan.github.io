<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Kran</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Kran">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Kran">
<meta property="og:description" content="blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="QiKran">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Kran" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Kran</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-day16-集合2、泛型、枚举" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/day16-%E9%9B%86%E5%90%882%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E6%9E%9A%E4%B8%BE/" class="article-date">
  <time datetime="2020-07-14T08:16:02.559Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/day16-%E9%9B%86%E5%90%882%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E6%9E%9A%E4%B8%BE/">day16-集合2、泛型、枚举</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="集合-Map"><a href="#集合-Map" class="headerlink" title="集合-Map"></a>集合-Map</h1><p>回顾一下Collection分支</p>
<ul>
<li>List,  有序、可重复<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector<ul>
<li>Stack  – 设计有缺陷，不建议使用</li>
</ul>
</li>
</ul>
</li>
<li>Set， 无序、不可重复的<ul>
<li>HashSet   –  <strong>组合了一个HashMap来实现的</strong></li>
<li>SortedSet<ul>
<li>TreeSet   –  <strong>组合了一个 TreeMap 来实现的</strong></li>
</ul>
</li>
</ul>
</li>
<li>Queue，FIFO（先进先出）<ul>
<li>PriorityQueue</li>
<li>Deque  – Double End Queue</li>
</ul>
</li>
</ul>
<p>Map</p>
<p>与Collection不同,Map存储的是键 - 值对，也就是 Key - Value, 本质上在Map内部，这个key和value会被封装成 Map.Entry 对象， 这个对象中拥有key和value  两个属性。</p>
<p>Map的特点：</p>
<ul>
<li>key是无序的、不可重复的</li>
<li>key可以为null, 注：对value没有任何要求。</li>
</ul>
<p>Map的常用操作</p>
<ul>
<li>put(K key, Value v)   把一对键值对存放当前的Map中</li>
<li>get(K key)   -&gt;   Value  通过key来获取Value</li>
<li>containsKey(K key)  判断当前的MAP中是否包含指定的key</li>
<li>containsValue(V value)   判断当前的MAP中是否包含指定的Value</li>
<li>三个方法可以把MAP转换成Set或Collection<ul>
<li>values()  -&gt;  Collection     把Map的所有值取出来，形成一个Collection并返回</li>
<li>keySet()   -&gt;  Set<K>   把MAP的所有KEY取出来，形成一个SET并返回，不含VALUE</li>
<li>entrySet()   -&gt; Set&lt;Entry&lt;K, V&gt;&gt;   把MAP的所有KEY和VALUE都取来，并封装成Entry对象，把Entry对象存放到Set中，并返回</li>
</ul>
</li>
</ul>
<p>Map的实现类 - HashMap</p>
<p>此类采用哈希算法来实现Map， 它的原理如下：</p>
<p>首先，当把一个对象put到HashMap中时，容器会调用此对象的hashcode方法获取对象的哈希码值，根据此哈希码值来计算出此对象应该存放的位置“桶”。</p>
<p>其次，当再把一个对象put到此HashMap中时，容器同样会调用此对象的hashcode方法获取对象的哈希码值，再根据此哈希码值来计算出此对象应该存放的位置“桶”。如果此时，这个位置”桶”被前面的对象给占用了，那么容器会调用此对象的equals()方法来判断此对象与<strong>占桶</strong>对象是否是<strong>“相等”</strong>，如果equals方法返回true，则相等，那么后面会覆盖前面。如果equals方法返回false,  则容器会把撞桶的对象采用平衡二叉树来存储，并且是用红黑树算法来决定它的位置。</p>
<p>最后，每个对象 的加入都重复上面的第2步。</p>
<p>有关二叉树的知识</p>
<ul>
<li><p>普通二叉树，就是把数据以左孩子和右孩子 的方式进行存储，不是采用线性结构，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的数据节点封装结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Node left;   <span class="comment">// 指向左孩子的指针</span></span><br><span class="line">    Node right;  <span class="comment">//指向右孩子的指针</span></span><br><span class="line">    Object data;  <span class="comment">//数据</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：普通二叉树使用价值不高</p>
</li>
<li><p>排序二叉树【Search Binary Tree】，是指左孩子节点值比它的根节点值要小，右孩子节点值比它的根节点值要大。每一个子树也是同样的规则</p>
<p>注：排序二叉有 前序、中序、后序三种遍历方式。</p>
</li>
<li><p>平衡二叉树【Balanced Binary Tree】，首先它是排序二叉树，再满足如下要求</p>
<ul>
<li>左子树的高度与右子树的高度差，其绝对值小于或等于1</li>
</ul>
</li>
</ul>
<hr>
<h3 id="SortedMap-接口"><a href="#SortedMap-接口" class="headerlink" title="SortedMap [接口]"></a>SortedMap [接口]</h3><blockquote>
<p>可排序的Map, 它是Map的子接口，提供了自动排序的功能。</p>
<p>它要求存放在此容器中的key是能够比较的。API 中提供了两种比较的接口</p>
<ul>
<li><p>java.lang.Comparable 接口 【可比较器的】</p>
<p>它里面有一个 <code>compareTo方法</code>。</p>
</li>
<li><p>java.util.Comparator 接口 【比较器】</p>
<p>它里面有一个 <code>compare</code> 方法</p>
</li>
</ul>
<p>第一： 如果我们不传递比较器到SortedMap中，则要求你加入到此容器的中对象必需要实现 <code>Comparable</code> 接口，这样一来，当你开始添加第2个对象时，容器会把你传入的对象强制类型转换成 <code>Comparable</code> 接口，并且调用对象的<code>compareTo</code>方法，从而决定他们之间的大小，也就决定了存放的位置。</p>
<p>第二：如果我们传递了一个比较器对象到此容器中，此种情况下，就不要求被添加的对象去实现<code>Comparable</code> 接口，而是通过这个比较器去比较。它的原理如下：</p>
<p>​    - 从添加第2个对象开始，调用比较器的<code>compare</code> 方法，并把前面已经存在的1个对象和刚加入的对象做参数传递给这个<code>compare</code> 方法，由这个方法决定两个对象的大小，如果返回0，表示相同，后面的会把前面的覆盖掉，如果返回-1,表示后加入的比前面的小。如果返回1，表示后加入的比前面的大。</p>
</blockquote>
<h4 id="实现类：TreeMap"><a href="#实现类：TreeMap" class="headerlink" title="实现类：TreeMap"></a>实现类：TreeMap</h4><blockquote>
<p>底层采用<strong>平衡二叉树</strong>来实现。</p>
</blockquote>
<p>常用方法：</p>
<ul>
<li><p>public TreeMap()    要求被添加对象要实现 <code>Comparable</code> 接口</p>
<p>注：在JDK, 以下几种常用类型都是实现了 <code>Comparable</code> 接口的，</p>
<ul>
<li>Integer, Long</li>
<li>String</li>
<li>Date</li>
<li>..</li>
</ul>
<p>所以，我们使用Map时，Key的类型尽量使用 Integer, Long, String, 如果你的Key是一个自定义类型，那最好实现 <code>Comparable</code> 接口。</p>
</li>
<li><p>public TreeMap(Comparator c)   传入比较器， 这种方式更加灵活，对Key没有实现 <code>Comparable</code> 接口的要求。</p>
</li>
<li><p>public TreeMap(Map m);</p>
</li>
</ul>
<p>…</p>
<h4 id="再来看看-TreeSet"><a href="#再来看看-TreeSet" class="headerlink" title="再来看看 TreeSet"></a>再来看看 TreeSet</h4><blockquote>
<p>此实现类实现了 <code>SortedSet</code> 接口，此类本质上是组合了 <code>TreeMap</code>对象。利用了 TreeMap的Key的位置来存储元素。所以，对于TreeSet而言，它同样有如下构造</p>
<ul>
<li>public TreeSet()     要求被添加了对象实现 <code>Comparable</code> 接口</li>
<li>public TreeSet(Comparator c)  由于传入了比较器，所以，不要求 元素实现 Comparable 接口。</li>
</ul>
</blockquote>
<h2 id="JCF小结"><a href="#JCF小结" class="headerlink" title="JCF小结"></a>JCF小结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Iterable</span><br><span class="line">	\- java.util.Collection</span><br><span class="line">			\- java.util.List</span><br><span class="line">					\- ArrayList    数组实现的</span><br><span class="line">					\- LinkedList	双向链表实现的</span><br><span class="line">					\- Vector</span><br><span class="line">			\- java.util.Set</span><br><span class="line">					\- HashSet   哈希算法+红黑树， 组合了 HashMap</span><br><span class="line">					\- java.util.SortedSet</span><br><span class="line">							\- TreeSet   平衡二叉树，组合了 TreeMap</span><br><span class="line">			\- java.util.Queue</span><br><span class="line">					\- PriorityQueue      优先队列</span><br><span class="line">					\- java.util.Deque    双端队列</span><br><span class="line">							\- ArrayDeque   数组</span><br><span class="line">			</span><br><span class="line">java.util.Map</span><br><span class="line">	\- HashMap		哈希算法</span><br><span class="line">	\- java.util.SortedMap</span><br><span class="line">				\- TreeMap	平衡二叉树实现</span><br><span class="line">				</span><br><span class="line"><span class="comment">//两个做比较的接口</span></span><br><span class="line">java.lang.Comparable&lt;T&gt;</span><br><span class="line">java.util.Comparator&lt;T&gt;</span><br></pre></td></tr></table></figure>

<h2 id="泛型-Generic"><a href="#泛型-Generic" class="headerlink" title="泛型 Generic"></a>泛型 Generic</h2><blockquote>
<p>泛型就是<strong>类型参数化</strong></p>
<p>泛型有如下特点：</p>
<ol>
<li>泛型是编译时的概念，在运行时并不存在泛型。</li>
<li>泛型不存在多态【因为它只是编译期的概念】</li>
</ol>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List a = <span class="keyword">new</span> ArrayList(); <span class="comment">//ok</span></span><br><span class="line">Object b = <span class="keyword">new</span> Student(); <span class="comment">//ok</span></span><br><span class="line">List&lt;Object&gt; ab = <span class="keyword">new</span> ArrayList&lt;Student&gt;(); <span class="comment">//compile error</span></span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; ab = <span class="keyword">new</span> ArrayList&lt;Student&gt;(); <span class="comment">//ok</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">List&lt;Student&gt; ab = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="泛型字母"><a href="#泛型字母" class="headerlink" title="泛型字母"></a>泛型字母</h3><blockquote>
<p>就是一个泛型的符号代替，一般使用单个字母，如：T, K, V, E, S, …</p>
</blockquote>
<h3 id="泛型类的定义"><a href="#泛型类的定义" class="headerlink" title="泛型类的定义"></a>泛型类的定义</h3><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类型&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    	</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    </span><br><span class="line">    在类型中定义了泛型字母，在属性和方法中就可以使用这个泛型字母 T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//采用组合模式</span></span><br><span class="line">	<span class="keyword">private</span> LinkedList&lt;T&gt; container;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SimpleStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//初始化这个容器</span></span><br><span class="line">		<span class="keyword">this</span>.container = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//把元素放在第一个位置</span></span><br><span class="line">		<span class="keyword">this</span>.container.push(element); <span class="comment">//等价于调用 addFirst()</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//永远取出列表中的第1个元素</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.container.pop(); <span class="comment">//等 价于调用 removeFirst()</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.container.isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.container.size();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//只返回本栈的栈顶元素，但是此元素并不从栈中移除</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.container.peek();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SimpleStack&lt;Integer&gt; ss1 = <span class="keyword">new</span> SimpleStack&lt;&gt;();</span><br><span class="line">    ss1.push(<span class="number">12</span>); <span class="comment">//ok</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SimpleStack&lt;String&gt; ss2 = <span class="keyword">new</span> SimpleStack&lt;&gt;();</span><br><span class="line">    ss2.push(<span class="string">"jack"</span>); <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="泛型方法的定义"><a href="#泛型方法的定义" class="headerlink" title="泛型方法的定义"></a>泛型方法的定义</h3><blockquote>
<p>此处所指是指 在类的层面上，没有定义泛型字母，而在方法中需要使用泛型。</p>
<p>泛型方法的定义一般都在 工具类，因为工具类的方法都是静态的。</p>
<p>语法：</p>
<p>修饰符 <T> 返回类型 方法名(T p, … )throws 异常列表 { … }</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">   	<span class="comment">//属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ma</span><span class="params">()</span> </span>&#123;  ....  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//泛型方法: 在返回类型和修饰符之间，要单独定义泛型字母，这样一来，在方法体中，就可以使用这个泛型字母。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">mb</span><span class="params">(T p)</span> </span>&#123;  ...   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="泛型通配符-wildcards"><a href="#泛型通配符-wildcards" class="headerlink" title="泛型通配符 wildcards"></a>泛型通配符 wildcards</h3><ul>
<li>? 通配任意类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//ok</span></span><br><span class="line">intList.add(<span class="number">100</span>); <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//ok</span></span><br><span class="line">strList.add(<span class="string">"jack"</span>); <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">List&lt;?&gt; hehe = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//ok</span></span><br><span class="line">hehe.add(<span class="keyword">null</span>);  <span class="comment">//ok</span></span><br><span class="line">hehe.add(<span class="string">"jack"</span>); <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;?&gt; container)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(Object o  : container) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>进一步对通配符进行限定，可以限定类型上限，也可以限定类型下限</p>
<p>&lt;? extends  类型&gt;   指定上限</p>
<p>&lt;? super 类型&gt;        指定下限</p>
<h4 id="集合的工具类-Collections"><a href="#集合的工具类-Collections" class="headerlink" title="集合的工具类 Collections"></a>集合的工具类 Collections</h4><blockquote>
<p>方法详见API文档</p>
<p>addAll()</p>
<p>sort()</p>
<p>ncopies()</p>
<p>shuffle()</p>
<p>….</p>
</blockquote>
<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 [enum]"></a>枚举 [enum]</h2><blockquote>
<p>同样是一种类型，利用 <strong>enum</strong> 关键字来定义,  编译完成后，也是字节码文件。</p>
<p><strong>枚举是一种类型安全的常量类</strong></p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> 枚举名 &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">   	<span class="comment">//1.普通属性，同 class 一样，使用不多</span></span><br><span class="line">    <span class="comment">//2.常量属性，也就是枚举本身的公开静态常量, 每一个枚举常量，都是枚举本身的一个实例。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//常量属性</span></span><br><span class="line">    SPRING,</span><br><span class="line">    SUMMER,</span><br><span class="line">    AUTUMN,</span><br><span class="line">    WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：拥有固定值的信息适合定义成枚举，如：四季、星期、月份、交通信号灯、扑克牌花色、扑克牌点数、…</p>
</blockquote>
<h4 id="枚举的特点"><a href="#枚举的特点" class="headerlink" title="枚举的特点"></a>枚举的特点</h4><ol>
<li>它的构造方法一定是私有的。</li>
<li>枚举中也可以定义抽象方法，每一个枚举常量都必需要实现这个抽象方法。</li>
<li>我们定义的枚举，都自动继承于 java.lang.Enum<T> </li>
</ol>
<h3 id="为什么-说枚举常量是类型安全的常量呢？"><a href="#为什么-说枚举常量是类型安全的常量呢？" class="headerlink" title="为什么 说枚举常量是类型安全的常量呢？"></a>为什么 说枚举常量是类型安全的常量呢？</h3><blockquote>
<p>因为枚举的常量，都是指向本类的实例，不是其它的类型。</p>
<p>因为枚举的构造方法默认就是私有的，而且只能是私有的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constant</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Constant SPRING = <span class="keyword">new</span> Constant();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Constant SUMMER = <span class="keyword">new</span> Constant();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Constant AUTUMN = <span class="keyword">new</span> Constant();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Constant WINTER = <span class="keyword">new</span> Constant();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Constant</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上的类就是枚举的本质，改成使用 enum 来定义如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">    SPRING,</span><br><span class="line">    SUMMER,</span><br><span class="line">    AUTUMN,</span><br><span class="line">    WINTER;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseXX</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数season取出常量类 Constant的四个常量之一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convert</span><span class="params">(Constant season)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(season == Constant.SPRING) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"春天"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(season == Constant.SUMMER) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        String s = convert(Constant.SPRING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ol>
<li><p>定义一个扑克牌花色 的枚举, 包含 黑、红、梅、方 四个枚举常量</p>
</li>
<li><p>定义一个扑克牌点数的枚举，包含 1，2，3，4，5，。。。，J,Q,K  13个枚举常量</p>
</li>
<li><p>定义一个卡片类[Card], 内置2个属性， 花色和点数， 提供构造方法、getter/setter、 toString, hashcode,equals方法</p>
</li>
<li><p>定义一个扑克牌类[Poker], 提供如下属性：</p>
<ul>
<li>private List<Card> cards;</li>
<li>private boolean hasKing; //是否包含大小王，如果此属性为真 ，则cards中要含大小王。如果为假，则cards中不含大小王。</li>
</ul>
<p>再定义如下方法</p>
<ul>
<li>空参构造， 相当于hasKing属性为假，不含大小王来填充 cards</li>
<li>带boolean 类型构造，由用户决定是否要含大小王，如果传入真，则要包含大小王来填充 cards</li>
<li>public List<Card> newPoker() { }  //获取一封新的扑克牌</li>
<li>public void shuffle(List<Card> cards) {}  //洗牌</li>
<li>public void play(List<Card> cards, int player, int cardsForEach) {}  //发牌，其中，cards代表扑克牌，player代表玩家数量， cardsForEach 代表每个玩家发多少张牌。 此方法要求把每个玩家的牌打印出来。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/day16-%E9%9B%86%E5%90%882%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E6%9E%9A%E4%B8%BE/" data-id="ckcmpx8710018cghc27bd6y2t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day15-集合框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/day15-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="article-date">
  <time datetime="2020-07-14T08:16:02.550Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/day15-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">day15-集合框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="集合框架-JCF"><a href="#集合框架-JCF" class="headerlink" title="集合框架 [JCF]"></a>集合框架 [JCF]</h2><p>Java Collection Framework, 它是由一组API组成，主要是针对容器的封装，底层有不同的实现，比如：有基于数组的实现，也有链表、哈希算法、二叉树的实现。</p>
<p>在JAVA中，数据的容器有两种</p>
<ol>
<li>基于值的存储， 有：List, Set</li>
<li>基于键、值对的存储, 有 Map</li>
</ol>
<p>基于值的存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.util.Collection</span><br><span class="line">			\- List  有序、可排序、可重复</span><br><span class="line">				\- ArrayList    基于数组的实现</span><br><span class="line">				\- LinkedList	基于链表的实现</span><br><span class="line">				\- Vector       同ArrayList, 它是多线程安全的，它的所有方法都是同步方法</span><br><span class="line">			\- set   无序、不可排序，不可重复</span><br><span class="line">				\- HashSet      使用哈希算法实现的</span><br><span class="line">				\- SortedSet	是Set的一子接口，它是可排序的，当然，也不能重复</span><br><span class="line">					\- TreeSet  使用二叉树实现的。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：由于在JAVA中，数组容器在操作上有诸多不便，所以，API提供了JCF供我们使用。如此多的类型，它们各自的特点是不同的。</p>
</blockquote>
<p>针对 List 来说，它的特点是元素有序、可排序，而且可重复，提供了基于数组和双向链表的两种不同的实现，我们在选择时，可以根据实际的情况进行选择。</p>
<p>Iterable 接口</p>
<ul>
<li>Iterator iterator() ;    返回当前集合的迭代器</li>
</ul>
<p>Collection的操作方法</p>
<ul>
<li>boolean add(T  element)     往容器中添加一个新元素</li>
<li>boolean addAll(Collection allElement)  往容器中添加指定容器中的所有元素</li>
<li>boolean remove(T element)  从容器中移除指定的对象</li>
<li>boolean removeAll(Collection elements)  从当前集合中删除指定集合中的所有元素</li>
<li>void clear()   清空容器</li>
<li>boolean contains(T element)   判断当前容器是否包含指定的元素</li>
<li>boolean containsAll(Collection elements) </li>
<li>int size();  获取当前集合有效元素的个数</li>
<li>toArray();  把集合转换成数组</li>
<li>Iterator iterator();   返回指向当前集合的迭代器</li>
</ul>
<p>Iterator 接口</p>
<ul>
<li>boolean hasNext()  判断迭代器中是否有下一个可使用的元素</li>
<li>T next()    取出迭代器指向的元素，并把指针向下移动一次。</li>
</ul>
<hr>
<p>List 【有序、不可重复】</p>
<ul>
<li>T get(int index)    根据下标来访问元素</li>
<li>void set(int index, T element)   把元素Element放到指定的位置</li>
<li>List subList(int start, int end)    求子集，含start位置，不含end位置,  返回的是新的集合</li>
<li>boolean isEmpty() ;  </li>
</ul>
<p>List的实现类</p>
<ul>
<li>ArrayList<ul>
<li>public ArrayList()</li>
<li>public ArrayList(int size);   </li>
<li>public ArrayList(Collection c)</li>
</ul>
</li>
<li>LinkedList<ul>
<li>public LinkedList();</li>
<li>public LinkedList(Collection c)</li>
</ul>
</li>
</ul>
<h4 id="栈的特点-Stack"><a href="#栈的特点-Stack" class="headerlink" title="栈的特点  Stack"></a>栈的特点  Stack</h4><blockquote>
<p>先进后出，FILO[First In, Last Out], 一般只提供针对栈顶的操作，包含：进栈，出栈，判断栈是否为空，以及栈中的元素个数</p>
</blockquote>
<h4 id="队列的特点-Queue"><a href="#队列的特点-Queue" class="headerlink" title="队列的特点  Queue"></a>队列的特点  Queue</h4><blockquote>
<p>先进先出， First In, First Out[ FIFO ], 一般提从队头的操作【增、删、查】, 包含入队、出列操作</p>
<p>在JCF的API中，有提供这个接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.Queue  [接口]</span><br><span class="line">  			\- java.util.Deque  【接口】</span><br></pre></td></tr></table></figure>

<p>它的方法主要有如下6个，集中在3个功能上，如下 ：</p>
<p><strong>添加操作</strong></p>
<ul>
<li>add(E element)   如果队列容量不够，抛出异常</li>
<li>offer(E element)   如果队列容量不够，则执行失败返回false</li>
</ul>
<p><strong>删除操作</strong></p>
<ul>
<li><h2 id="remove-如果队列为空，则抛出异常"><a href="#remove-如果队列为空，则抛出异常" class="headerlink" title="remove()  如果队列为空，则抛出异常"></a>remove()  如果队列为空，则抛出异常</h2></li>
<li>poll()  如果队列为空，则返回null</li>
</ul>
<p><strong>查询操作</strong></p>
<ul>
<li>element()   如果队列为空，则抛出异常</li>
<li>peek()      如果队列为空，则返回null</li>
</ul>
<h5 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h5><blockquote>
<p>double end Queue, 简称 Deque， 它支持两端进行操作。它是 Queue的子接口。</p>
</blockquote>
<p>同样，由于它是双端的操作，所以，它的核心方法比 Queue多一倍，也是集中在3个功能。</p>
<p>添加操作、删除操作、查询操作</p>
<h3 id="Collection集合的结构类图"><a href="#Collection集合的结构类图" class="headerlink" title="Collection集合的结构类图"></a>Collection集合的结构类图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Iterable</span><br><span class="line">		\- java.util.Collection</span><br><span class="line">				\- java.util.List</span><br><span class="line">						\- ArrayList</span><br><span class="line">						\- Vector</span><br><span class="line">						\- LinkedList</span><br><span class="line">				\- java.util.Set</span><br><span class="line">						\- HashSet</span><br><span class="line">						\- java.util.SortedSet</span><br><span class="line">								\- TreeSet</span><br><span class="line">				\- java.util.Queue</span><br><span class="line">						\- PriorityQueue</span><br><span class="line">						\- java.util.Deque</span><br><span class="line">								\- ArrayDeque</span><br><span class="line"><span class="comment">//注： 以上带包的都是 接口，不带包的都是 实现类</span></span><br></pre></td></tr></table></figure>



<h3 id="Set-操作"><a href="#Set-操作" class="headerlink" title="Set 操作"></a>Set 操作</h3><blockquote>
<p>几乎与Collection一样。</p>
<p>它的特点是：无序、不可重复</p>
</blockquote>
<p><strong>实现类：HashSet</strong></p>
<blockquote>
<p>它是如何做到 无序以及不可重复的呢？</p>
</blockquote>
<p>首先，当我们把一个对象添加到 HashSet时，这个容器会调用对象的 hashcode()方法，得到一个整数。根据这个整数来计算出此对象应该存放的位置。</p>
<p>其次，当我们再次添加一个对象时，同样会调用此对象的hashcode()方法，得到一个整数，算出它该存储的位置，此时，如果这个位置已经被占用了，则会调用它的 equals()方法，如果返回true, 说明此对象与之前的对象相等，则放弃存入。 如果返回false, 则表示对象不相等，则利用红黑树来存储进行纵向扩展。</p>
<p>注：</p>
<p>上面我们所讲的原理，其实是HashMap的原则，而HashSet中，只是组合了 HashMap，并且只是利用了它的 Key， 而Value永远是同 一个 Object.</p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ol>
<li>把上节课布置的模排诗改成竖排诗的作业利用集合重新来实现一下。</li>
<li>利用循环，随机生成10W个1-100之间的整数，请利用集合来统计出每个整数出现的次数</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/day15-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" data-id="ckcmpx8700017cghc7jjfg91d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day14-作业" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/day14-%E4%BD%9C%E4%B8%9A/" class="article-date">
  <time datetime="2020-07-14T08:16:02.548Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/day14-%E4%BD%9C%E4%B8%9A/">day14-作业</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ol>
<li>设计一类，利用 RandomAccessFile 类来读取给定文本文件的最后一行。方法自定义</li>
<li>设计一类，利用FileReader和FileWriter  来实现把一首<strong>横排诗</strong>进行 <strong>竖排</strong>, 如下：</li>
</ol>
<p>原诗为：</p>
<p>​    杜甫<br>迟日江山丽，<br>春风花草香。<br>泥融飞燕子，<br>沙暖睡鸳鸯。<br>江碧鸟逾白，<br>山青花欲燃。<br>今春看又过，<br>何日是归年。</p>
<p>经过你的算法，重新排列为：</p>
<p>​        迟 春 x</p>
<p>​        日 风 x</p>
<p>杜    江 花 x</p>
<p>甫    山 草 x</p>
<p>​        丽 香 x</p>
<p>​        ， 。 ，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/day14-%E4%BD%9C%E4%B8%9A/" data-id="ckcmpx86y0016cghch8fa57ov" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day14-IO流-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/day14-IO%E6%B5%81-2/" class="article-date">
  <time datetime="2020-07-14T08:16:02.532Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/day14-IO%E6%B5%81-2/">day14-IO流-2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="基本类型读写的流：-》-DataInputStream-DataOutputStream"><a href="#基本类型读写的流：-》-DataInputStream-DataOutputStream" class="headerlink" title="基本类型读写的流：-》 DataInputStream/DataOutputStream"></a>基本类型读写的流：-》 DataInputStream/DataOutputStream</h3><blockquote>
<p>利用此类型我可以把基本数据类型持久化到文件中</p>
</blockquote>
<p>案例：</p>
<p>设计一个id从1开始依次增长的算法，要求即使程序退出后，下次再启动时，ID依然是增长的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> index = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> 类名() &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = generateId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">generateId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//利用IO流来持久化个值。</span></span><br><span class="line">        <span class="keyword">return</span> index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ol>
<li>首先，如果这个文件不存在，创建这个文件，并且把2L值写入到这个文件中。返回1L</li>
<li>如果文件存在，则先读取这个文件中的值，然后再把这个值+1，写回到这个文件中。</li>
</ol>
<p><strong>详见 IDGenerate.java</strong> </p>
<h3 id="读写对象的流-gt-ObjectInputStream-ObjectOutputStream"><a href="#读写对象的流-gt-ObjectInputStream-ObjectOutputStream" class="headerlink" title="读写对象的流 -&gt; ObjectInputStream/ObjectOutputStream"></a>读写对象的流 -&gt; ObjectInputStream/ObjectOutputStream</h3><blockquote>
<p>这个可以进行对象的读写，要求对象的类型必需要实现 <strong>java.io.Serializable</strong> 接口</p>
<p>这个接口叫对象序列化接口，可以用来持久化对象的状态。</p>
</blockquote>
<p>有关对象的读写操作，有两个细节需要注意：</p>
<ul>
<li>被实持久化的对象必需要实现 <code>java.io.Serialiable</code> 接口</li>
<li>如果某些属性不想被持久化外，则使用<code>transient</code> 修饰符进行修饰。</li>
</ul>
<h3 id="随机读写流-RandomAccessFile"><a href="#随机读写流-RandomAccessFile" class="headerlink" title="随机读写流  RandomAccessFile"></a>随机读写流  RandomAccessFile</h3><blockquote>
<p>它是一个即支持读、也支持写的<strong>节点流</strong>,  它实现了 DataInput和DataOutput 接口。</p>
<p>它还支持移动访问的位置</p>
</blockquote>
<p>常用方法</p>
<ul>
<li>public RandomAccessFile(String path, String mode)</li>
<li>public RandomAccessFile(File path, String mode)</li>
<li>seek(long pos)</li>
<li>getFilePointer()  -&gt;  long</li>
<li>…</li>
</ul>
<blockquote>
<p>主要的打开模式有：</p>
<ul>
<li>“r”  以只读模式打开</li>
<li>“rw” 以读写模式打开</li>
</ul>
</blockquote>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><blockquote>
<p>字符流是以字符为单位处理的流，它实际上是JVM针对字符文件所做的特殊处理。</p>
<p>本质上，有了字节流，就可以处理字符文件，但是，不方便。</p>
</blockquote>
<h3 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.io.Reader</span><br><span class="line">		\- FileReader</span><br><span class="line">		\- CharArrayReader</span><br><span class="line">		\- FilterReader</span><br><span class="line">			\- PushbackReader</span><br><span class="line">		\- BufferedReader     [*]  带缓存，而且整行的读取   readLine()</span><br><span class="line">		\- InputStreamReader  [字节流到字符流的桥接器]</span><br><span class="line">		\- ....</span><br></pre></td></tr></table></figure>

<p><strong>Reader常用方法</strong></p>
<ul>
<li>read()                读取单个字符</li>
<li>read(char[] buf)               尝试读取buf.length个字符</li>
<li>read(char[] buf, int offset, int length)   尝试从偏移量offset 处 读取 length个字符</li>
<li>close()  释放</li>
</ul>
<p><strong>BufferedReader的方法</strong></p>
<ul>
<li>readLine()   -&gt;  String     此方法以换行符为终止符，但是，返回的字符串是不包含这个终止符。</li>
</ul>
<h3 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.io.Writer</span><br><span class="line">		\- FileWriter</span><br><span class="line">		\- CharArrayWriter</span><br><span class="line">		\- OutputStreamWriter   [字节输出流到字符输出流的桥接器]</span><br><span class="line">		\- BufferedWriter</span><br><span class="line">		\- PrintWriter    [*] 自带缓存，而且支持整行的写入,  println()</span><br><span class="line">    	\- ...</span><br></pre></td></tr></table></figure>

<p><strong>Writer的常用方法：</strong></p>
<ul>
<li>write(int c)      写入传入的单个字符</li>
<li>write(char[] buf)    把buf 中的字符写入到输出流，写入的是 buf.length个字符</li>
<li>write(char[] buf, int offset, int len)   同上,写入的是 len个字符</li>
<li>close()</li>
</ul>
<h3 id="有关字节流到字符流的桥接口"><a href="#有关字节流到字符流的桥接口" class="headerlink" title="有关字节流到字符流的桥接口"></a>有关字节流到字符流的桥接口</h3><blockquote>
<p>有些标准输入输出设备被定义成了 字节流，可是我们需要把它转换成字符流，这里就可以使用这个桥接器，如下：</p>
<p>BufferedReader br = new BufferedReader(new FileReader(“hello.txt”));  //指向文本的字符输入流</p>
<p>再看：</p>
<p>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</p>
<p>再看，我有一个指向文本文件字节流, 并且重新指定字符集为 GBK</p>
<p>BufferedReader br = new BufferedReader(</p>
<p>​                        new InputStreamReader(</p>
<p>​                            new FileInputStream(“hello.txt”), “GBK”));</p>
</blockquote>
<p><strong>InputStreamReader的构造器</strong></p>
<ul>
<li>InputStreamReader(InputStream in)    采用默认字符集做转换器</li>
<li>InputStreamReader(InputStream in, String charsetName)   指定的字符集做转换器</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/day14-IO%E6%B5%81-2/" data-id="ckcmpx86x0015cghc8f8afwgd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day13-IO流" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/day13-IO%E6%B5%81/" class="article-date">
  <time datetime="2020-07-14T08:16:02.523Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/day13-IO%E6%B5%81/">day13-IO流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><blockquote>
<p>是用来操作文件内容的。而文件的内容可以分成两个类别：</p>
<ul>
<li>二进制文件，【所有除文本文件之外的文件，比如：音频、视频、图片、word, ppt, excel, …】</li>
<li>文本文件， 能够使用记事本打开的，使用者可以直接读懂的文件。比如：【.txt, .java, .md, …】</li>
</ul>
</blockquote>
<p>注：</p>
<p><strong>不管二进制文件，还是文本文件，其本质都是010101的存储，不同在于它们的编码方式不同。</strong></p>
<h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h2><blockquote>
<p>是以字符集进行编码的，而字符集是由不同的国家和地区根据自己的情况制定的，并且得到国际上的认可。比如：中国地区的字符集编码就是 GBK,   西区地区的字符集是  ISO-8859-1,  国际编码字符集是 UTF-8， …</p>
<p>每个国家的字符集都是公开的</p>
</blockquote>
<h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><blockquote>
<p>一般来讲，都是由软件厂商自己定义的编码规则，有的是公开的，有的是商业密秘，这些编码规则往往与创建此类格式的软件和解析此类格式软件形成一个闭环。比如：Word格式的文件，就必需使用 微软公司出品的Office办公软件去创建和解析。</p>
</blockquote>
<p>注：</p>
<p>文本文件也是一种二进制文件，之所以把它单列出来，是因为它使用较为频繁，而且不方便使用二进制去处理它，而是使用字符去处理它更为方便。</p>
<p>所以，文本文件是以<strong>字符</strong>为单位进行处理的，在JAVA 的IO流包中，专门提供了一系列的API来处理文本文件，这类流叫字符流。</p>
<p>二进制文件是以<strong>字节</strong>为单位进行处理的，在JAVA的IO流包中，也专门提供了一系统的API来处理二进制文件，这类流叫字节流。</p>
<h2 id="IO流的API"><a href="#IO流的API" class="headerlink" title="IO流的API"></a>IO流的API</h2><blockquote>
<p>包: java.io </p>
</blockquote>
<p><strong>输入流和输出流</strong></p>
<blockquote>
<p>输入和输出都是以JVM为边界的，往JVM内存写入的，叫输入流。</p>
<p>反过来，从JVM内存中向外输出的，叫输出流。</p>
</blockquote>
<p>输入      ||||||||                 |||||||        输出</p>
<p>——–&gt;  ||||||||JVM内存 ||||||||    ———–&gt;</p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><blockquote>
<p>有负责读取的输入流和负责写入的输出流</p>
</blockquote>
<h4 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.io.InputStream        --- 抽象父类</span><br><span class="line">        \- java.io.FileInputStream</span><br><span class="line">        \- java.io.ByteArrayInputStream</span><br><span class="line">        \- java.io.FilterInputStream</span><br><span class="line">        		\- java.io.BufferInputStream</span><br><span class="line">        		\- java.io.DataInputStream     </span><br><span class="line">        		\- java.io.PushBackInputStream</span><br><span class="line">        \- java.io.ObjectInputStream</span><br><span class="line">抽象出一些共性的接口</span><br><span class="line">java.io.DataInput</span><br><span class="line">		\- java.io.ObjectInput</span><br></pre></td></tr></table></figure>

<p><strong>InputStream中的共性方法:</strong></p>
<ul>
<li>int read()    –&gt;  读取1个字节， 效率较低。 返回值 -1表示读到了文件尾[EOF], 非-1的返回值 表示读到的字节本身。</li>
<li>int read(byte[] buf)    —&gt;   尝试最多读取 buf.length个字节，这个方法的返回值表示实际读到的字节个数。如果读到文件尾【EOF】，则返回-1</li>
<li>int read(byte[] buf, int offset, int length)    —&gt; 从offset位置处开始尝试最多读取 length个字节，返回值的意义同第2个方法。</li>
<li>void close()    –&gt; 释放流源释。</li>
<li>available()   </li>
</ul>
<h4 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.io.OutputStream        ---- 抽象父类</span><br><span class="line">		\- java.io.FileOutputStream</span><br><span class="line">		\- java.io.BufferedOutputStream</span><br><span class="line">		\- java.io.DataOutputStream</span><br><span class="line">		\- java.io.ObjectOutputStream</span><br><span class="line">		\- java.io.ByteArrayOutputStream</span><br><span class="line">抽象出一些共性的接口</span><br><span class="line">java.io.DataOutput</span><br><span class="line">		\- java.io.ObjectOutput</span><br></pre></td></tr></table></figure>

<p><strong>OutputStream中的共性方法：</strong></p>
<ul>
<li>void write(int byte);   写入单个字节</li>
<li>void write(byte[] buf);   写入 buf.length个字节</li>
<li>void write(byte[] buf, int offset, int length) ;   写入 length个字节</li>
<li>void close()</li>
</ul>
<p><strong>以上这些流又可以分成两种，一种是本身具备流的读写能力的，一种是在原有流的基础上，添加新的功能的流。</strong></p>
<h4 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h4><blockquote>
<p>就是本身拥有流的读写能力，比如：FileInputStream / FileOutputStream,  ByteArrayInputStream/ByteArrayOutputStream</p>
<p>从构造器的参数也可以看出，这类流的构造是以”源” 为参数的。</p>
</blockquote>
<h4 id="过滤流"><a href="#过滤流" class="headerlink" title="过滤流"></a>过滤流</h4><blockquote>
<p>本身并没有流的读写能力，它必需借助于节点流来构造。比如：DataInputStream/DataOutputStream, BuffredInputStream/BufferedOutputStream, …</p>
<p>从构造器的参数也可以看出，这类流的构造是以 “流” 来参数。</p>
</blockquote>
<p>这是一种装饰模式，我们来看一下各自的创建过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点流的创建</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"sample.md"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤流的创建</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"sample.md"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设我要构造一个带缓存，能读基本数据类型的流</span></span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">    					<span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                            <span class="keyword">new</span> FileInputStream(<span class="string">"id.dat"</span>)));</span><br></pre></td></tr></table></figure>



<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>设计一个类型，提示如下方法：</p>
<ol>
<li>利用字节流完成一个文件的拷贝。要求方法的参数传入一个文件名，如果是目录，则提示不支持。拷贝后的文件名与原文件存放在同一个目录中，并且文件名后面添加 <strong>_副本</strong> 字样，如：原文件名为 <strong>a.txt</strong>, 则拷贝出来的文件名为 <strong>a_副本.txt</strong></li>
<li>本题可选： 再实现一个方法，完成文件夹的COPY， 要求COPY整个文件夹，包含子文件夹和子文件。【可以使用递归】</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/day13-IO%E6%B5%81/" data-id="ckcmpx86c0013cghc4z2l1p48" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day12-内部类、File" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/day12-%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81File/" class="article-date">
  <time datetime="2020-07-14T08:16:02.509Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/day12-%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81File/">day12-内部类、File</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="String-和-StringBuilder-使用"><a href="#String-和-StringBuilder-使用" class="headerlink" title="String 和 StringBuilder 使用"></a>String 和 StringBuilder 使用</h1><blockquote>
<p>String是一个不可变对象，所以，我们在做字符串拼接时，会产生大量的临时对象，这对性能是有影响的，所以，JDK推出了 StringBuilder来做字符串拼接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"this is my email address:"</span>;</span><br><span class="line">str = str + <span class="string">"yjf210000@163.com"</span>;  <span class="comment">//产生临时对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而使用 StringBuilder，则会大大减小临时对象的创建，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.append(<span class="string">"this is my email address:"</span>);</span><br><span class="line">builder.append(<span class="string">"yjf210000@163.com"</span>);</span><br></pre></td></tr></table></figure>

<p>所以，以后尽量使用 StringBuilder来做字符串的拼接。</p>
</blockquote>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><blockquote>
<p>就是类中嵌套另一个类型，根据内部类所处的位置不同，可以有如下形式：</p>
<ul>
<li>成员内部类     【一个类做为另一个类的普通成员】</li>
<li>静态内部类     【一个类做为另一个类的静态成员】</li>
<li>局部内部类      【一个类做为方法的成员】</li>
<li>匿名内部类       【特殊的局部内部类，也是方法的成员】</li>
</ul>
</blockquote>
<h3 id="成员内部类-【member-inner-class】"><a href="#成员内部类-【member-inner-class】" class="headerlink" title="成员内部类 【member inner class】"></a>成员内部类 【member inner class】</h3><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberInner</span> </span>&#123;</span><br><span class="line">        <span class="comment">//属性</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//方法</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//外部类的方法</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>成员内部类可以直接所在外部类的所有成员。</li>
<li>对于私有的成员内部类来说，只供这个外部类使用，外界不能访问这个私有成员。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>内部的语法比较特殊，不方便调用</li>
</ul>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//静态成员 - 内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">        <span class="comment">//属性</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//方法</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//外部类的方法</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>可以直接访问外部类的静态成员</li>
<li>在外部类看来，公开静态内部类可以“上升”为外部类。【利用静态导入】,  这样一来，这个静态内部类即拥有了内部类的优势，也有了外部类的访问特征。</li>
</ul>
<p>注：</p>
<p>一般来说，使用静态内部类都是为了封装一个“算法/功能”, 这个算法/功能 只为所在的外部类去服务。</p>
<h3 id="局部内部类-Local-Inner-Class"><a href="#局部内部类-Local-Inner-Class" class="headerlink" title="局部内部类 [Local Inner Class]"></a>局部内部类 [Local Inner Class]</h3><blockquote>
<p>它定义在外部类的成员方法中</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ma</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义一个局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalInner</span> </span>&#123;</span><br><span class="line">            <span class="comment">//属性</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hehe</span><span class="params">()</span> </span>&#123; .... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建这个局部内部类的实例，并调用它的方法</span></span><br><span class="line">        LocalInner li = <span class="keyword">new</span> LocalInner();</span><br><span class="line">        li.hehe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：局部内部类的特点</p>
<ul>
<li>除了可以访问所在外部类的所有成员外，它还可以访问所在方法的局部变量。在JDK8之前，要求这个局部变量必需是final的，JDK8之后，没有了这个限制。</li>
</ul>
</blockquote>
<h3 id="匿名内部类【Anonymous-Inner-class】"><a href="#匿名内部类【Anonymous-Inner-class】" class="headerlink" title="匿名内部类【Anonymous Inner class】"></a>匿名内部类【Anonymous Inner class】</h3><blockquote>
<p>是没有名字的局部内部类。</p>
</blockquote>
<p>它是利用接口或抽象父类来完成的，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHehe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hehe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ma</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        IHehe ic = <span class="keyword">new</span> IHehe()&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hehe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ic.hehe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//或</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">new</span> IHehe() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hehe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.hehe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<blockquote>
<p>同局部内部类</p>
</blockquote>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><blockquote>
<p>针对操作系统中的文件进行操作，JDK提供了一个类型:<code>java.io.File</code> 类，这个类型是对文件的一种抽象，它封装了文件的各种操作，包含：创建文件、删除文件、列举文件等，但不能对文件的内容进行读和写。</p>
<p>这个<code>File</code>不是单指狭义的”文件”,它也含文件夹。</p>
<p>因为文件夹是一种特殊的文件，它是包含其它文件或子文件夹的 <strong>“文件”</strong></p>
</blockquote>
<h3 id="JAVA中如何把操作系统中的资源抽象成File的实例？"><a href="#JAVA中如何把操作系统中的资源抽象成File的实例？" class="headerlink" title="JAVA中如何把操作系统中的资源抽象成File的实例？"></a>JAVA中如何把操作系统中的资源抽象成File的实例？</h3><blockquote>
<p>首先要理解，操作系统中的资源是指什么？ – 本质上就是路径[PATH], 而路径有两种表达方式：</p>
<ul>
<li>相对路径</li>
<li>绝对路径</li>
</ul>
<p>而路径可以使中 字符串 来表达，它是包含一种特定格式的字符串，如：</p>
<p><code>D:\2020-03\workspace\note</code>      –&gt; 绝对路径</p>
<p><code>workspace\note</code>        —&gt; 相对路径</p>
</blockquote>
<h3 id="java-io-File中的常用方法"><a href="#java-io-File中的常用方法" class="headerlink" title="java.io.File中的常用方法"></a>java.io.File中的常用方法</h3><ul>
<li>public File(String path)    以操作系统中合格的字符串路径来实例化一个 File的实例</li>
<li>public File(String parentPath, String path)   在父目录parentPath下面创建一个 File实例</li>
<li>public File(File parent, String path)    同上</li>
<li>…</li>
<li>…</li>
</ul>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ol>
<li><p>设计一个类，提供如下方法：</p>
<ul>
<li>方法一：用来统计指定目录下的文件数量，不含文件夹的数量。 </li>
<li>方法二：重载一个方法，用来统计指定扩展名的文件数量，比如：.java文件的数量</li>
<li>方法三：用来统计指定文件夹下面的所有文件的大小之和。单个文件的大小，可以通过 file.length() 方法来获取，单位是 kb, 如果小于1kb的，则以 b 为单位来显示。</li>
<li>方法四：同样，再重载一个方法，用来统计指定文件夹下面某类扩展名文件的大小，比如 d:\temp 目录下所有.java文件的大小，单位是 kb, 如果小于1kb的，则以 b 为单位来显示。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/day12-%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81File/" data-id="ckcmpx86v0014cghc423o00k2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day11-作业" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/day11-%E4%BD%9C%E4%B8%9A/" class="article-date">
  <time datetime="2020-07-14T08:16:02.491Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/day11-%E4%BD%9C%E4%B8%9A/">day11-作业</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ol>
<li>请设计一个类型，提供如下方法  <code>**待完成</code>！**</li>
</ol>
<ul>
<li><p>public int countWords(CharSequence content) { … },   此方法用来统计 content 中的英文单词个数， 请使用正则表达式来做，单词的正则表达式请自行编写， content内容请使用StringBuilder 来存储，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hooray! It&#39;s snowing! It&#39;s time to make a snowman.James runs out. He makes a big pile of snow. He puts a big snowball on top. He adds a scarf and a hat. He adds an orange for the nose. He adds coal for the eyes and buttons.In the evening, James opens the door. What does he see? The snowman is moving! James invites him in. The snowman has never been inside a house. He says hello to the cat. He plays with paper towels.A moment later, the snowman takes James&#39;s hand and goes out.They go up, up, up into the air! They are flying! What a wonderful night!The next morning, James jumps out of bed. He runs to the door.He wants to thank the snowman. But he&#39;s gone.</span><br></pre></td></tr></table></figure>
</li>
<li><p>再写一个方法，统计出以上内容中，每个单词[不考虑大小写]出现的次数，数据结构请自行定义，但请使用数组来存储，并按照单词出现的次数的降序排序。</p>
</li>
<li><p>请一个类，来测试你的算法</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/day11-%E4%BD%9C%E4%B8%9A/" data-id="ckcmpx86c0012cghcamuuhd1g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DAY11-字符串、正则" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/DAY11-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%AD%A3%E5%88%99/" class="article-date">
  <time datetime="2020-07-14T08:16:02.482Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/DAY11-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%AD%A3%E5%88%99/">DAY11-字符串、正则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><blockquote>
<p>它是使用较为频繁的类型，而且也是不可变对象。【同数字、和日期、时间】</p>
<p>所以，这些类型都是不可以被继承的。</p>
<p>相关的类型：</p>
<ul>
<li>java.lang.String</li>
<li>java.lang.StringBuilder</li>
<li>java.lang.StringBuffer</li>
<li>java.lang.CharSequence</li>
<li>java.util.regex.Pattern</li>
<li>java.util.regex.Matcher</li>
</ul>
<p>注：CharSequence 本质上是 char[] , 它的实现类中，就是组合了 char[]。</p>
</blockquote>
<p>CharSequence 常用方法：</p>
<ul>
<li>charAt(int index)     返回指定位置处的字符</li>
<li>length()    返回字符序列中的有效字符个数</li>
<li>subsequence(int start, int end)    求子串</li>
<li>toString()   返回字符串表示形式，同样是副本。</li>
</ul>
<p>JDK8之后，为了增加具体子类的功能，添加2个默认方法：</p>
<ul>
<li>chars()</li>
<li>codePoints()</li>
</ul>
<p>String中的常用方法</p>
<ul>
<li>indexOf()</li>
<li>lastIndexOf()</li>
<li>substring()</li>
<li>replace()</li>
<li>length()</li>
<li>split()</li>
<li>match()</li>
<li>….</li>
</ul>
<p>StringBuilder和StringBuffer 的常用方法</p>
<blockquote>
<p>这两个类中的方法和实现都是一模一样的，唯一的不同点在于：</p>
<ul>
<li>StringBuilder 不是多线程安全的，是轻量级的。</li>
<li>StringBuffer 是多线程安全的，是重量级的，也就是它的所有方法都是同步的【加了互斥锁】</li>
</ul>
<p>所以，在非多线程的情况下，建议选用 StringBuilder。</p>
<p>常用方法：</p>
<ul>
<li>append()  方法，这个作用相当于String的”+”运算符。就是把字符串追加到原来的字符序列中。</li>
<li>reverse() 方法，反转此容器的字符序列 并返回它的副本。</li>
</ul>
</blockquote>
<p><strong>字符串的切割和组合</strong></p>
<ul>
<li><p>split() 方法， 用指定的分割符来切割字符串，它有如下2个重载</p>
<ul>
<li>split(String regex);  此方法相当于调用了 <strong>split(regex, 0)</strong> 方法</li>
<li>split(String regex, int limit);  其中,limit 有三种值<ul>
<li>当limit==0时，表示使用regex尽可能多的次数去切割原始字符串，并把尾部的空白结果给去掉</li>
<li>当limit&lt; 0时，表示使用regex尽可能多的次数去切割原始字符串，并保留尾部的空白结果。</li>
<li>当limit&gt;0时， 表示使用regex去匹配 limit-1 次。</li>
</ul>
</li>
</ul>
</li>
<li><p>join()  方法， JDK8 才加入的一个静态方法，方便我们组装字符串数组。</p>
</li>
</ul>
<p><strong>字符串和字节数组的转换</strong></p>
<blockquote>
<p>字符转换成字节叫 编码[encode]</p>
<p>字节转换成字符叫 解码[decode]</p>
<p>在字符进行编解码的过程中，都需要指定字符集/编码集，常用字符集有：</p>
<ul>
<li>UTF-8， 支持中文， 动态字节编码</li>
<li>ISO-8859-1  西欧字符集，不支持中文</li>
<li>GBK  国标码， 双字节编码</li>
<li>ASCII 码， 也不支持中文，单字节编码</li>
</ul>
</blockquote>
<p>相关的方法</p>
<p><strong>把字符转换成字节的方法：</strong></p>
<ul>
<li>getBytes()   采用平台的默认字符集来进行编码</li>
<li>getBytes(String charsetName)  采用指定的字符集进行编码，这个字符集的字符串要合规定。</li>
</ul>
<p><strong>把字节转换字符的方法：</strong></p>
<ul>
<li>new String(byte[] arr);   以默认字符集来解码给定的字节数组</li>
<li>new String(byte[] arr, String charsetName);  以指定的字符集来编码给定的字节数组</li>
</ul>
<p><strong>乱码的由来</strong></p>
<blockquote>
<p>当你的编解码字符集选择不一样时，就会造成乱码。</p>
</blockquote>
<h2 id="正则表达式-【Regular-Expression】"><a href="#正则表达式-【Regular-Expression】" class="headerlink" title="正则表达式 【Regular Expression】"></a>正则表达式 【Regular Expression】</h2><blockquote>
<p>由字母、数字和一些特殊字符所组成的有特定含义的字符序列。</p>
<p>它的目的是用来去快速匹配目标字符序列的。</p>
<p>在JDK1.4引入了对正则表达式的支持。</p>
<p>java.util.regex包 </p>
<ul>
<li>Pattern 类 </li>
<li>Matcher 类</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="comment">//如果要判断这个字符串是否包含字符序列 or</span></span><br><span class="line"><span class="keyword">if</span>(str.indexOf(<span class="string">"or"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//说明这个字符串中是存在 字符序列or 的</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">if</span>(str.contains(<span class="string">"or"</span>)) &#123;</span><br><span class="line">	<span class="comment">//说明这个字符串中是存在 字符序列 or的</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">以上的判断都是基于精准匹配的，再看如下的代码</span><br><span class="line">String content = <span class="string">"yjf210000@163.com"</span>;</span><br><span class="line"><span class="comment">//如何去判断这个字符串是否包含一个 “有效的” 邮箱地址？</span></span><br><span class="line"><span class="comment">//这是一种基于 “模式"的判断，不是一个具体的字符序列的判断</span></span><br><span class="line"><span class="comment">//这种判断，上面的方法是做不到的，这里就可以使用 正则表达式 来完成判断。</span></span><br><span class="line"><span class="comment">//因为正则表达式就是一种基于模式的判断, 模式就是规则。</span></span><br><span class="line">String regex = <span class="string">"^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$"</span>;  <span class="comment">//合法邮箱的规则</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span>(content.matches(regex)) &#123;</span><br><span class="line">    <span class="comment">// 说明，这个字符串 content 是匹配模式 regex</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的例子中，这个 matches 方法只能做一次性的匹配，不能做搜索</p>
<p>也不能去把匹配的字符序列给 单独找出来。</p>
<p>如果要完成以上2点，则需要使用 <code>Pattern</code> 和 <code>Matcher</code></p>
<p>Pattern类型是 正则表达式/模式 载体，它负责解析这个模式。</p>
<p>Matcher类型是 存储匹配的结果的。</p>
<p>实际上，String.matches(regex) 方法，等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String content = <span class="string">"yjf210000@163.com"</span>;</span><br><span class="line">String regex = <span class="string">"^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$"</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Pattern p = Pattern.compile(regex);</span><br><span class="line">Matcher m = p.matcher(content); </span><br><span class="line"><span class="keyword">if</span>(m.matches()) &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//与 String中的matches方法等价</span></span><br><span class="line"><span class="keyword">if</span>(content.matches(regex)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式的规则"><a href="#正则表达式的规则" class="headerlink" title="正则表达式的规则"></a>正则表达式的规则</h3><blockquote>
<p>详见API文档</p>
</blockquote>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><blockquote>
<p>是一种特殊的类型，分成2类</p>
<ul>
<li>异常  Exception</li>
<li>错误  Error</li>
</ul>
</blockquote>
<p>这两种都被定义可抛出的类型，所以，JDK中提供了一个父类：Throwable </p>
<p>java.lang.Throwable</p>
<p>​    \- java.lang.Error       一种比较严重的错误</p>
<p>​    \- java.lang.Exception</p>
<blockquote>
<p>异常是一种JAVA程序的信号传递机制。它可以通过属性封装更多的信息量。</p>
</blockquote>
<p>首先，我们来看一下父类 <code>Throwable</code>的构造方法和常用方法</p>
<ul>
<li>public Throwable()</li>
<li>public Throwable(String message)</li>
<li>public Throwable(String message, Throwable cause)</li>
<li>getMessage()</li>
<li>getCause()</li>
<li>printStackTrace();    打印异常的堆栈信息</li>
</ul>
<p>再来看看子类 <code>Exception</code> 中的方法</p>
<p>完全继承于 <code>Throwable</code> ，没有自定义任何的个性化方法。</p>
<h3 id="JAVA中处理异常的语法"><a href="#JAVA中处理异常的语法" class="headerlink" title="JAVA中处理异常的语法"></a>JAVA中处理异常的语法</h3><h4 id="消极的处理方法"><a href="#消极的处理方法" class="headerlink" title="消极的处理方法"></a>消极的处理方法</h4><blockquote>
<p>就是利用 throw 关键字把异常向上抛出【抛给上一级调用者】</p>
<p>如果这类异常需要在方法层面上进行申明，则利用 throws 在方法层面申请即可，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回类型 方法名(参数列表) <span class="keyword">throws</span> 申明的异常类型列表 &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：多个异常类型之间使用 逗号 隔开。</p>
</blockquote>
<h4 id="积极的处理方法"><a href="#积极的处理方法" class="headerlink" title="积极的处理方法"></a>积极的处理方法</h4><blockquote>
<p>利用 try catch finally 块来处理异常，语法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//把有可能出现异常的代码块放入其中</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型 | 异常类型 | 异常类型 e  ) &#123;</span><br><span class="line">    <span class="comment">//处理异常的代码</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型 e) &#123;   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//不管try 块中的代码是否出现的异常，此处的代码是一定会被执行的。</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>如果你打算针对不同的异常类型做不一样的处理，则建议分开写多个 catch 块。</p>
<p>如果你的异常处理逻辑是一样的，则合在一起写。</p>
<p>注：</p>
<p>如果有多个catch块时，应该把父异常的 catch 块写在后面。</p>
</blockquote>
<p><strong>这个异常处理的代码结构有多种变种，如下：</strong></p>
<ul>
<li>try catch 变种</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">1</span> e) &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">2</span> e) &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>try finally 变种</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Exception</span><br><span class="line">			\-  RuntimeException    运行时异常，在JVM内部发生的异常，也就是没有超出JVM的边界。</span><br><span class="line">					\- NullPointerException</span><br><span class="line">					\- ArrayIndexOutOfBoundsException</span><br><span class="line">					\- TypeMismatchException</span><br><span class="line">					\- ClassCastException</span><br><span class="line">					\- IllegalStateException</span><br><span class="line">					\- NoSuchElementException</span><br><span class="line">					\- ArithmeticException</span><br><span class="line">					\- ....</span><br><span class="line">    </span><br><span class="line">			\-  非运行时异常          【除RuntimeException分支之外的异常】，超出了JVM的边界的。</span><br><span class="line">					\- InterruptedException</span><br><span class="line">					\- FileNotFoundException</span><br><span class="line">					\- IOException</span><br><span class="line">					\- SQLException</span><br><span class="line">					\- SocketException</span><br><span class="line">					\- BindException</span><br><span class="line">					\- UnsupportedEncodingException</span><br><span class="line">					\- ...</span><br></pre></td></tr></table></figure>

<p>注：</p>
<blockquote>
<p>针对运行时异常[<strong>RuntimeException</strong>] ,JVM 不强制程序员去处理，也就是说，我们不处理这种异常，JVM也不会去检查，也就不会出现编译错误。针对此类异常，JVM希望程序员要编码谨慎，多做判断，以此来尽可能地避免此类异常的发生。</p>
<p>如果是非运行时异常，则JVM会强制要求程序员去处理，那么程序员有2个选择</p>
<ul>
<li>直接在方法层面申明抛出  【消极的处理】</li>
<li>利用try catch 去捕获取并处理  【积极的处理】</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/DAY11-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%AD%A3%E5%88%99/" data-id="ckcmpx8580000cghca00e7yzy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day10-作业" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/day10-%E4%BD%9C%E4%B8%9A/" class="article-date">
  <time datetime="2020-07-14T08:16:02.464Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/day10-%E4%BD%9C%E4%B8%9A/">day10-作业</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><p>作业一、<br>我们需要设计一组类来操作图书类[Book]数据，包含<br>添加图书、查询图书、删除图书、统计数量、清空等操作。</p>
<p>其中，Book实例类包含如下属性</p>
<ul>
<li>id</li>
<li>图书名</li>
<li>图书作者</li>
<li>isbn 【表示图书的编码】</li>
</ul>
<p>为了更好地体现OO的思想，设计一个图书业务接口如下：</p>
<p>public interface IBookService {</p>
<pre><code>void addBook(Book b); //添加图书

void deleteByIsbn(String ibsn); //

void deleteByAuthor(String author); //

void updateBook(Book b); //附加题

int size(); //统计书的数量

void clear(); //清空所有图书

Book selectByIsbn(String isbn);

Book[] getAllBooks(); //获取所有图书</code></pre><p>}</p>
<p>//请写一个业务接口的实现类，完成以上所有的业务方法。</p>
<p>并提供测试。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/day10-%E4%BD%9C%E4%B8%9A/" data-id="ckcmpx86b0010cghc22nch53n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day10-核心API" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/day10-%E6%A0%B8%E5%BF%83API/" class="article-date">
  <time datetime="2020-07-14T08:16:02.447Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/day10-%E6%A0%B8%E5%BF%83API/">day10-核心API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h1><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><h3 id="横向关系"><a href="#横向关系" class="headerlink" title="横向关系"></a>横向关系</h3><ol>
<li><p>组合关系 【关系较强】</p>
<p>是关联的一种，两个类之间的关系较强，属于整体与局部关系。 局部不能脱离整体单独存在，在创建整体对象时，局部被一起创建出来。</p>
<p>也是<code>HAS A</code> 关系</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> Heart heart; <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>.birth = <span class="keyword">new</span> Date(); <span class="comment">//也是组合</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>.heart = <span class="keyword">new</span> Heart(); <span class="comment">//这个Heart不是由外部传入的，而是在创建整体对象时，它自己来创建局部对象。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p><strong>组合关系的ＵＭＬ图形是：实线+实心菱形</strong></p>
</li>
<li><p>聚合关系 【关系比组合关系略弱】</p>
<p>也是关联关系的一种，两个类之间的关系稍弱，两个类在语义上是”平等”。 两个对象可以单独存在，在创建主对象时，辅助对象不需要被创建，而是由外部传入。</p>
<p>也是<code>HAS A</code> 关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> Heart heart; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> Address homeAddress; <span class="comment">//家庭住址</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Address homeAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">// 聚合</span></span><br><span class="line">        <span class="keyword">this</span>.birth = <span class="keyword">new</span> Date(); <span class="comment">//也是组合</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>.heart = <span class="keyword">new</span> Heart(); <span class="comment">//这个Heart不是由外部传入的，而是在创建整体对象时，它自己来创建局部对象。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>.homeAddress = homeAddress; <span class="comment">//聚合，对象由外界传入。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p><strong>聚合关系的UML图形是：实心线+空心菱形</strong></p>
</li>
<li><p>依赖关系 【关系最弱】</p>
<p>它是一种“USE A” 关系，表示一个类使用了另一个类，这种方法往往以局部变量的方式出现在代码中，如：我们在程序经常使用一些工具类或辅助类，都是这种关系。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IAFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IA <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IA</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IAFactory与IA 的关系就是 依赖关系，IAFactory依赖于 IA</span></span><br></pre></td></tr></table></figure>

<p>以上三种关系由强到弱分别是： 组合，聚合，依赖</p>
<p>注：</p>
<p><strong>依赖的UML图形是：虚线+箭头</strong></p>
</li>
</ol>
<h3 id="纵向关系"><a href="#纵向关系" class="headerlink" title="纵向关系"></a>纵向关系</h3><ol>
<li><p>继承关系</p>
<p>它是 “IS A” 的关系。</p>
<p><strong>它的UML图形是：实线+空心三角形</strong></p>
</li>
<li><p>实现关系</p>
<p>它也是”IS A “ 的关系。</p>
<p><strong>它的UML图形是： 虚线+空心三角形</strong></p>
</li>
</ol>
<h2 id="三大类型的操作"><a href="#三大类型的操作" class="headerlink" title="三大类型的操作"></a>三大类型的操作</h2><h3 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h3><ol>
<li>8大基本类型的包装类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>    --&gt;		Byte</span><br><span class="line"><span class="keyword">short</span>	--&gt;		Short</span><br><span class="line"><span class="keyword">int</span>		--&gt; 	Integer</span><br><span class="line"><span class="keyword">long</span>	--&gt;		Long</span><br><span class="line"><span class="keyword">double</span>	--&gt; 	Double</span><br><span class="line"><span class="keyword">float</span>	--&gt;		Float</span><br><span class="line"><span class="keyword">char</span>	--&gt;		Character</span><br><span class="line"><span class="keyword">boolean</span>	--&gt;		Boolean</span><br></pre></td></tr></table></figure>

<p>以上8种基本类型与对应的对象类型之间可以实现自动解封箱[auto boxing/unboxing]。</p>
<p> 如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line">Integer j = i; <span class="comment">//ok, 自动封箱</span></span><br><span class="line">Integer k = <span class="keyword">new</span> Integer(i); <span class="comment">//ok, 手动封箱</span></span><br><span class="line"><span class="keyword">int</span> m = k; <span class="comment">//ok, 自动解箱</span></span><br><span class="line"><span class="comment">//注：虽然可以自动解封箱，但是，它们还是有区别的，如：</span></span><br><span class="line">j = <span class="keyword">null</span>; <span class="comment">//ok</span></span><br><span class="line">i = <span class="keyword">null</span>; <span class="comment">//compile error</span></span><br></pre></td></tr></table></figure>

<p>这8种基本类型与对象类型以及字符串形式如何转换？</p>
<p>以 Integer 为例</p>
<ul>
<li>把 int 转换成字符串  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line">String istr = String.valueOf(i);</span><br><span class="line">或：</span><br><span class="line">String istr = i.toString(); <span class="comment">//Compile Error</span></span><br><span class="line">String istr = Integer.valueOf(i).toString(); <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>

<ul>
<li>把字符串转换成整数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String istr = <span class="string">"19"</span>;</span><br><span class="line">String jstr = <span class="string">"0xff3"</span>;</span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(istr); <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span> j = Integer.parseInt(jstr, <span class="number">16</span>); <span class="comment">//	</span></span><br><span class="line"><span class="comment">//或1</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">new</span> Integer(istr).intValue(); <span class="comment">//ok</span></span><br><span class="line"><span class="comment">//或2</span></span><br><span class="line"><span class="keyword">int</span> i = Integer.valueOf(istr).intValue(); <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>



<p><strong>抽象父类 Number</strong> </p>
<blockquote>
<p>是为了以统一的方式来使用各种不同的数字类型而准备的。</p>
<p>为了扩展而存在的。</p>
</blockquote>
<p><strong>相关的包</strong></p>
<ul>
<li>java.lang包</li>
<li>java.text包</li>
<li>java.math包</li>
</ul>
<p><strong>数字的格式化</strong></p>
<h3 id="日期型"><a href="#日期型" class="headerlink" title="日期型"></a>日期型</h3><blockquote>
<p>在JDK8之前，日期相关的API分布：</p>
<ul>
<li>java.util.Date, TimeZone</li>
<li>java.sql.Date, TimeStamp, Time, Calendar ,  GregorianCalendar</li>
<li>java.text.DateFormat , SimpleDateFormat</li>
</ul>
</blockquote>
<p><strong>java.util.Date</strong></p>
<p>常用方法：</p>
<ul>
<li>public Date()     以当前的系统时间来构造日期对象</li>
<li>public Date(long t)   以指定毫秒数来构建日期对象</li>
</ul>
<p><strong>java.util.Calendar 和  GregorianCalendar</strong></p>
<p>常用方法：</p>
<ul>
<li>getInstance()   获取Calendar的实例，是一个工厂方法  </li>
<li>set(int type)     设置日历对象中的指定成员，这个成员由 type指定，这个type是Calendar定义的常量，如：YEAR, MONTH, DAY_OF_MONTH, ….</li>
<li>get(int type)    获取日历对象中的指定成员，这个type同上。</li>
<li>getTime()     获取此日历对象中的日期，返回一个 Date</li>
<li>setTime(Date d)   给此日历对象设计一个新的日期。</li>
</ul>
<p><strong>DateFormat和SimpleDateFormat</strong></p>
<p>常用方法：</p>
<ul>
<li><p>public SimpleDateFormat(String pattern)   构造方法，根据指定 的模式来创建SimpleDateFormat对象</p>
</li>
<li><p>format() 方法，格式化日期对象，返回字符串</p>
</li>
<li><p>parse() 方法， 解析方法，把字符串解析成日期对象，并返回</p>
</li>
</ul>
<h4 id="JDK8中的全新日期处理API"><a href="#JDK8中的全新日期处理API" class="headerlink" title="JDK8中的全新日期处理API"></a>JDK8中的全新日期处理API</h4><p>所在的包：</p>
<p><strong>java.time</strong> </p>
<p>java.time.format</p>
<p>java.time.temporal</p>
<p>…</p>
<p>主要的类型 【这些类型都是不可变的，线程安全的】</p>
<ul>
<li>LocalDate   处理年月日的类型</li>
<li>LocalTime   处理时、分、秒</li>
<li>LocalDateTime  年月日，时分秒</li>
<li>Duration   计算时间分和差距</li>
<li>Period        计算年月日 的差距</li>
<li>Clock          可选类</li>
<li>…</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/day10-%E6%A0%B8%E5%BF%83API/" data-id="ckcmpx86b0011cghcfdli1onp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/15/SpringMVC-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%B5%8B%E8%AF%95/">SpringMVC-控制器测试</a>
          </li>
        
          <li>
            <a href="/2020/07/15/Spring+mybatis%E6%95%B4%E5%90%88/">Spring+mybatis整合</a>
          </li>
        
          <li>
            <a href="/2020/07/15/Spring%20MVC-3/">Spring MVC-3</a>
          </li>
        
          <li>
            <a href="/2020/07/15/spring%20MVC-2/">spring MVC-2</a>
          </li>
        
          <li>
            <a href="/2020/07/15/Spring%20MVC-1/">Spring MVC-1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 QiKran<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>